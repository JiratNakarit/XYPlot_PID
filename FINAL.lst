CCS PCD C Compiler, Version 5.015, 5967               26-¾.Â.-17 14:09

               Filename:   C:\Users\Teng_is_happy\Documents\Embeded Project\Final_Project\FINAL.lst

               ROM used:   7598 bytes (22%)
                           Largest free fragment is 23118
               RAM used:   832 (10%) at main() level
                           986 (12%) worst case
               Stack size: 128

*
0C00:  GOTO    2760
*
0C28:  GOTO    1392
*
0C30:  GOTO    1280
*
0C38:  GOTO    13D6
*
0C50:  GOTO    109E
0C54:  GOTO    11B8
*
0C74:  GOTO    132A
*
0C90:  GOTO    20A0
0C94:  GOTO    2212
0C98:  GOTO    135E
*
0CB8:  GOTO    141C
0CBC:  GOTO    1464
.................... #import(file="BITWISE_LIB.o") 
.................... /* 
.................... *************************** C SOURCE FILE ************************************ 
....................  
.................... project   : 
.................... filename  : BITWISE_LIB.C 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #define BITWISE_LIB_C_SRC 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             MODULES USED                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "BITWISE_LIB.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : BITWISE_LIB.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  BITWISE_LIB_INCLUDED 
.................... #define  BITWISE_LIB_INCLUDED 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include "CONFIG_PIC24.H"   
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
*
14AE:  MOV     W5,[W15++]
14B0:  MOV     #C,W5
14B2:  REPEAT  #3
14B4:  MOV     [W5++],[W15++]
14B6:  MOV     W0,W4
14B8:  MOV     W1,W5
14BA:  MOV     W2,W6
14BC:  MOV     W3,W7
14BE:  CLR     W0
14C0:  CLR     W1
14C2:  CLR     W2
14C4:  CLR     W3
14C6:  BCLR    W8.0
14C8:  BTSS    W7.F
14CA:  BRA     14D6
14CC:  BSET    W8.0
14CE:  NEG     W4,W4
14D0:  COM     W5,W5
14D2:  COM     W6,W6
14D4:  COM     W7,W7
14D6:  IOR      W4,  W5,W9
14D8:  BRA     NZ,14DE
14DA:  IOR      W6,  W7,W9
14DC:  BRA     Z,1508
14DE:  MOV     #473,W9
14E0:  BTSC    W3.4
14E2:  BRA     14FA
14E4:  BCLR.B  42.0
14E6:  RLC     W4,W4
14E8:  RLC     W5,W5
14EA:  RLC     W6,W6
14EC:  RLC     W7,W7
14EE:  RLC     W0,W0
14F0:  RLC     W1,W1
14F2:  RLC     W2,W2
14F4:  RLC     W3,W3
14F6:  DEC     W9,W9
14F8:  BRA     NZ,14E0
14FA:  SL      W9,#4,W9
14FC:  BCLR.B  42.0
14FE:  BCLR    W9.F
1500:  BCLR    W3.4
1502:  XOR     W9,W3,W3
1504:  BTSC    W8.0
1506:  BSET    W3.F
1508:  MOV     #12,W5
150A:  REPEAT  #3
150C:  MOV     [--W15],[W5--]
150E:  MOV     [--W15],W5
1510:  RETURN  
1512:  MOV     W8,[W15++]
1514:  MOV     #12,W8
1516:  REPEAT  #4
1518:  MOV     [W8++],[W15++]
151A:  CLR     W11
151C:  MUL.UU  W12,#0,W12
151E:  MOV     W3,W8
1520:  MOV     W7,W9
1522:  MOV     #7FF,W10
1524:  BCLR.B  42.0
1526:  BCLR.B  42.1
1528:  ASR     W8,#4,W8
152A:  AND     W10,W8,W8
152C:  CP0     W8
152E:  BRA     Z,1612
1530:  BCLR.B  42.0
1532:  BCLR.B  42.1
1534:  ASR     W9,#4,W9
1536:  AND     W10,W9,W9
1538:  CP0     W9
153A:  BRA     Z,1612
153C:  ADD     W9,W8,W8
153E:  BTSC    W9.B
1540:  BRA     154A
1542:  SUB     #3FF,W8
1544:  BRA     Z,1612
1546:  BRA     NC,1612
1548:  BRA     1550
154A:  MOV     #401,W10
154C:  ADD.B   W10L,W5L,W5L
154E:  BRA     C,1612
1550:  XOR     W3,W7,W13
1552:  BCLR.B  42.0
1554:  BCLR.B  42.1
1556:  AND     #F,W3
1558:  BSET    W3.4
155A:  AND     #F,W7
155C:  BSET    W7.4
155E:  MOV     W8,[W15++]
1560:  MUL.UU  W4,W1,W8
1562:  MUL.UU  W5,W0,W10
1564:  ADD     W8,W10,W10
1566:  ADDC    W9,W11,W11
1568:  ADDC    #0,W12
156A:  MUL.UU  W4,W2,W8
156C:  ADD     W8,W11,W11
156E:  ADDC    W9,W12,W12
1570:  MUL.UU  W5,W1,W8
1572:  CLR     W10
1574:  ADD     W8,W11,W11
1576:  ADDC    W9,W12,W12
1578:  ADDC    #0,W10
157A:  MUL.UU  W6,W0,W8
157C:  ADD     W8,W11,W11
157E:  ADDC    W9,W12,W12
1580:  ADDC    #0,W10
1582:  CLR     W11
1584:  MUL.UU  W4,W3,W8
1586:  ADD     W8,W12,W12
1588:  ADDC    W9,W10,W10
158A:  ADDC    #0,W11
158C:  MUL.UU  W5,W2,W8
158E:  ADD     W8,W12,W12
1590:  ADDC    W9,W10,W10
1592:  ADDC    #0,W11
1594:  MUL.UU  W6,W1,W8
1596:  ADD     W8,W12,W12
1598:  ADDC    W9,W10,W10
159A:  ADDC    #0,W11
159C:  MUL.UU  W7,W0,W8
159E:  ADD     W8,W12,W12
15A0:  ADDC    W9,W10,W10
15A2:  ADDC    #0,W11
15A4:  MOV     W12,W0
15A6:  CLR     W12
15A8:  MUL.UU  W5,W3,W8
15AA:  ADD     W8,W10,W10
15AC:  ADDC    W9,W11,W11
15AE:  ADDC    #0,W12
15B0:  MUL.UU  W6,W2,W8
15B2:  ADD     W8,W10,W10
15B4:  ADDC    W9,W11,W11
15B6:  ADDC    #0,W12
15B8:  MUL.UU  W6,W3,W8
15BA:  ADD     W8,W11,W11
15BC:  ADDC    W9,W12,W12
15BE:  MUL.UU  W7,W1,W8
15C0:  ADD     W8,W10,W10
15C2:  ADDC    W9,W11,W11
15C4:  ADDC    #0,W12
15C6:  MUL.UU  W7,W2,W8
15C8:  ADD     W8,W11,W11
15CA:  ADDC    W9,W12,W12
15CC:  MUL.UU  W7,W3,W8
15CE:  ADD     W8,W12,W12
15D0:  MOV     W10,W1
15D2:  MOV     W11,W2
15D4:  MOV     W12,W3
15D6:  MOV     #5,W4
15D8:  BCLR.B  42.0
15DA:  RRC     W3,W3
15DC:  RRC     W2,W2
15DE:  RRC     W1,W1
15E0:  RRC     W0,W0
15E2:  DEC     W4,W4
15E4:  BRA     NZ,15D8
15E6:  MOV     [--W15],W8
15E8:  INC     W8,W8
15EA:  IOR      W0,  W1,W6
15EC:  BRA     Z,15F0
15EE:  BRA     15F4
15F0:  IOR      W2,  W3,W6
15F2:  BRA     Z,1604
15F4:  BTSC    W3.4
15F6:  BRA     1604
15F8:  BCLR.B  42.0
15FA:  RLC     W0,W0
15FC:  RLC     W1,W1
15FE:  RLC     W2,W2
1600:  RLC     W3,W3
1602:  DEC     W8,W8
1604:  SL      W8,#4,W8
1606:  BCLR    W3.F
1608:  BTSC    W13.F
160A:  BSET    W3.F
160C:  BCLR    W3.4
160E:  XOR     W8,W3,W3
1610:  BRA     1618
1612:  MUL.UU  W0,#0,W0
1614:  MUL.UU  W0,#0,W2
1616:  BRA     1618
1618:  MOV     #1A,W8
161A:  REPEAT  #4
161C:  MOV     [--W15],[W8--]
161E:  MOV     [--W15],W8
1620:  RETURN  
1622:  MOV     W8,[W15++]
1624:  MOV     #12,W8
1626:  REPEAT  #4
1628:  MOV     [W8++],[W15++]
162A:  XOR     W3,W7,W13
162C:  MOV     W3,W8
162E:  MOV     W7,W9
1630:  MOV     #7FF,W10
1632:  BCLR.B  42.0
1634:  BCLR.B  42.1
1636:  ASR     W8,#4,W8
1638:  AND     W10,W8,W8
163A:  CP0     W8
163C:  BRA     Z,1716
163E:  BCLR.B  42.0
1640:  BCLR.B  42.1
1642:  ASR     W9,#4,W9
1644:  AND     W10,W9,W9
1646:  CP0     W9
1648:  BRA     Z,1716
164A:  CLR     W10
164C:  SUB     W8,W9,W12
164E:  BRA     NC,1656
1650:  ADD     #3FF,W12
1652:  BRA     C,1716
1654:  BRA     165E
1656:  MOV     #401,W11
1658:  SUB     W12,W11,W12
165A:  BRA     NC,1716
165C:  BRA     Z,1716
165E:  CLR     W8
1660:  CLR     W9
1662:  CLR     W10
1664:  CLR     W11
1666:  AND     #1F,W3
1668:  BSET    W3.4
166A:  AND     #1F,W7
166C:  BSET    W7.4
166E:  MOV     W12,[W15++]
1670:  MOV     #36,W12
1672:  SUB     W0,W4,W0
1674:  SUBB    W1,W5,W1
1676:  SUBB    W2,W6,W2
1678:  SUBB    W3,W7,W3
167A:  BRA     N,1680
167C:  BRA     C,168A
167E:  BRA     NZ,168C
1680:  ADD     W0,W4,W0
1682:  ADDC    W1,W5,W1
1684:  ADDC    W2,W6,W2
1686:  ADDC    W3,W7,W3
1688:  BRA     168C
168A:  BSET    W8.0
168C:  DEC     W12,W12
168E:  BRA     Z,16A6
1690:  BCLR.B  42.0
1692:  RLC     W0,W0
1694:  RLC     W1,W1
1696:  RLC     W2,W2
1698:  RLC     W3,W3
169A:  BCLR.B  42.0
169C:  RLC     W8,W8
169E:  RLC     W9,W9
16A0:  RLC     W10,W10
16A2:  RLC     W11,W11
16A4:  BRA     1672
16A6:  MOV     [--W15],W12
16A8:  BTSC    W11.5
16AA:  BRA     16AE
16AC:  BRA     16BA
16AE:  BCLR.B  42.0
16B0:  RRC     W11,W11
16B2:  RRC     W10,W10
16B4:  RRC     W9,W9
16B6:  RRC     W8,W8
16B8:  BRA     16C0
16BA:  DEC     W12,W12
16BC:  BCLR.B  42.0
16BE:  BRA     Z,1716
16C0:  BTSC.B  42.0
16C2:  BRA     16D6
16C4:  RLC     W0,W0
16C6:  RLC     W1,W1
16C8:  RLC     W2,W2
16CA:  RLC     W3,W3
16CC:  SUB     W0,W4,W4
16CE:  SUBB    W1,W5,W5
16D0:  SUBB    W2,W6,W6
16D2:  SUBB    W3,W7,W7
16D4:  BRA     NC,1700
16D6:  INC     W8,W8
16D8:  BRA     NZ,1700
16DA:  INC     W9,W9
16DC:  BRA     NZ,1700
16DE:  INC     W10,W10
16E0:  BRA     NZ,1700
16E2:  INC     W11,W11
16E4:  BRA     NZ,1700
16E6:  INC     W12,W12
16E8:  BRA     Z,1716
16EA:  BRA     1700
16EC:  DEC     W12,W12
16EE:  BRA     Z,1716
16F0:  BTSC    W11.4
16F2:  BRA     1700
16F4:  BCLR.B  42.0
16F6:  RLC     W8,W8
16F8:  RLC     W9,W9
16FA:  RLC     W10,W10
16FC:  RLC     W11,W11
16FE:  BRA     16F0
1700:  SL      W12,#4,W12
1702:  BCLR.B  42.0
1704:  BCLR    W12.F
1706:  BTSC    W13.F
1708:  BSET    W12.F
170A:  BCLR    W11.4
170C:  XOR     W12,W11,W3
170E:  MOV     W10,W2
1710:  MOV     W9,W1
1712:  MOV     W8,W0
1714:  BRA     1720
1716:  MOV     #0,W0
1718:  MOV     #0,W1
171A:  MOV     #0,W2
171C:  MOV     #0,W3
171E:  BRA     1720
1720:  MOV     #1A,W8
1722:  REPEAT  #4
1724:  MOV     [--W15],[W8--]
1726:  MOV     [--W15],W8
1728:  RETURN  
*
176E:  MOV     W5,[W15++]
1770:  MOV     #C,W5
1772:  REPEAT  #4
1774:  MOV     [W5++],[W15++]
1776:  MOV     W0,W4
1778:  MOV     W1,W5
177A:  MOV     W3,W7
177C:  MOV     W2,W6
177E:  BCLR.B  42.0
1780:  BCLR.B  42.1
1782:  RLC     W1,W1
1784:  SWAP    W1
1786:  AND     #FF,W1
1788:  CP0     W1
178A:  BRA     Z,1822
178C:  BCLR.B  42.0
178E:  BCLR.B  42.1
1790:  RLC     W3,W3
1792:  SWAP    W3
1794:  AND     #FF,W3
1796:  CP0     W3
1798:  BRA     Z,1822
179A:  ZE      W0,W0
179C:  ADD.B   W3L,W1L,W0L
179E:  BRA     C,17A8
17A0:  SUB     #7F,W0
17A2:  BRA     Z,1822
17A4:  BRA     NC,1822
17A6:  BRA     17AC
17A8:  ADD.B   #81,W0L
17AA:  BRA     C,1822
17AC:  XOR     W5,W7,W10
17AE:  BCLR.B  42.0
17B0:  BCLR.B  42.1
17B2:  AND     #FF,W5
17B4:  BSET    W5.7
17B6:  BCLR.B  42.0
17B8:  AND     #FF,W7
17BA:  BSET    W7.7
17BC:  MUL.UU  W4,W6,W2
17BE:  MUL.UU  W5,W6,W8
17C0:  ADDC    W8,W3,W3
17C2:  MOV     W9,W1
17C4:  BTSC.B  42.0
17C6:  INC     W1,W1
17C8:  BCLR.B  42.0
17CA:  MUL.UU  W7,W4,W8
17CC:  ADDC    W8,W3,W3
17CE:  ADDC    W9,W1,W1
17D0:  MUL.UU  W5,W7,W8
17D2:  ADDC    W8,W1,W1
17D4:  INC     W0,W0
17D6:  CP0     W1
17D8:  BTSC.B  42.1
17DA:  BRA     17DE
17DC:  BRA     17E4
17DE:  CP0     W3
17E0:  BTSC.B  42.1
17E2:  BRA     17EE
17E4:  BTSC    W1.F
17E6:  BRA     17EE
17E8:  RLC     W3,W3
17EA:  RLC     W1,W1
17EC:  DEC     W0,W0
17EE:  MOV     W1,W2
17F0:  BCLR.B  42.0
17F2:  BTSS    W3.7
17F4:  BRA     1808
17F6:  MOV     #FF00,W7
17F8:  AND     W3,W7,W3
17FA:  ADD     #100,W3
17FC:  ADDC    W2,#0,W2
17FE:  CP0     W2
1800:  BRA     NZ,1808
1802:  CP0     W3
1804:  BRA     NZ,1808
1806:  INC     W0,W0
1808:  SWAP    W0
180A:  BCLR.B  42.0
180C:  BCLR.B  42.1
180E:  RRC     W0,W1
1810:  BTSC    W10.F
1812:  BSET    W1.F
1814:  BCLR    W2.F
1816:  SWAP    W2
1818:  XOR.B   W2L,W1L,W1L
181A:  SWAP    W3
181C:  MOV.B   W3L,W2L
181E:  MOV     W2,W0
1820:  BRA     1828
1822:  MOV     #0,W0
1824:  MOV     #0,W1
1826:  BRA     1828
1828:  MOV     #14,W5
182A:  REPEAT  #4
182C:  MOV     [--W15],[W5--]
182E:  MOV     [--W15],W5
1830:  RETURN  
1832:  MOV     W5,[W15++]
1834:  MOV     #C,W5
1836:  REPEAT  #4
1838:  MOV     [W5++],[W15++]
183A:  CLR     W9
183C:  XOR     W1,W3,W9
183E:  MOV     W1,W6
1840:  MOV     W0,W5
1842:  MOV     W3,W8
1844:  MOV     W2,W7
1846:  RLC     W1,W1
1848:  SWAP    W1
184A:  ZE      W1,W1
184C:  CP0     W1
184E:  BRA     Z,18EC
1850:  RLC     W3,W3
1852:  SWAP    W3
1854:  ZE      W3,W3
1856:  CP0     W3
1858:  BRA     Z,18EC
185A:  CLR     W0
185C:  SUB.B   W1L,W3L,W0L
185E:  BRA     NC,1866
1860:  ADD.B   #7F,W0L
1862:  BRA     C,18EC
1864:  BRA     186C
1866:  SUB.B   #81,W0L
1868:  BRA     NC,18EC
186A:  BRA     Z,18EC
186C:  MOV     W5,W1
186E:  MOV     W6,W2
1870:  BSET    W2.7
1872:  AND     #FF,W2
1874:  AND     #FF,W8
1876:  BSET    W8.7
1878:  MOV     #19,W10
187A:  CLR     W3
187C:  CLR     W4
187E:  SUB     W1,W7,W1
1880:  SUBB    W2,W8,W2
1882:  BRA     N,1888
1884:  BRA     C,188E
1886:  BRA     NZ,1890
1888:  ADD     W1,W7,W1
188A:  ADDC    W2,W8,W2
188C:  BRA     1890
188E:  BSET    W4.0
1890:  DEC     W10,W10
1892:  BRA     Z,18A2
1894:  BCLR.B  42.0
1896:  RLC     W1,W1
1898:  RLC     W2,W2
189A:  BCLR.B  42.0
189C:  RLC     W4,W4
189E:  RLC     W3,W3
18A0:  BRA     187E
18A2:  CLR     W10
18A4:  BTSC    W3.8
18A6:  BRA     18AA
18A8:  BRA     18B6
18AA:  BCLR.B  42.0
18AC:  RRC     W3,W3
18AE:  BCLR    W3.7
18B0:  RRC     W4,W4
18B2:  RLC     W10,W10
18B4:  BRA     18BA
18B6:  DEC     W0,W0
18B8:  BRA     Z,18EC
18BA:  BTSC    W10.F
18BC:  BRA     NC,18C8
18BE:  RLC     W1,W1
18C0:  RLC     W2,W2
18C2:  SUB     W1,W7,W1
18C4:  SUBB    W2,W8,W2
18C6:  BRA     NC,18DA
18C8:  INC     W4,W4
18CA:  BRA     NZ,18DA
18CC:  INC     W3,W3
18CE:  BRA     NZ,18DA
18D0:  INC     W0,W0
18D2:  BRA     Z,18EC
18D4:  BRA     18DA
18D6:  DEC     W0,W0
18D8:  BRA     Z,18EC
18DA:  SWAP    W0
18DC:  RRC     W0,W1
18DE:  BSET    W1.F
18E0:  BTSS    W9.F
18E2:  BCLR    W1.F
18E4:  BCLR    W3.7
18E6:  XOR.B   W3L,W1L,W1L
18E8:  MOV     W4,W0
18EA:  BRA     18F2
18EC:  MOV     #0,W0
18EE:  MOV     #0,W1
18F0:  BRA     18F2
18F2:  MOV     #14,W5
18F4:  REPEAT  #4
18F6:  MOV     [--W15],[W5--]
18F8:  MOV     [--W15],W5
18FA:  RETURN  
*
1A96:  MOV     W5,[W15++]
1A98:  MOV     #C,W5
1A9A:  REPEAT  #3
1A9C:  MOV     [W5++],[W15++]
1A9E:  CLR     W9
1AA0:  MOV     #8000,W8
1AA2:  BTSC.B  43.0
1AA4:  XOR     W8,W3,W3
1AA6:  CP0     W0
1AA8:  BRA     NZ,1AB0
1AAA:  MOV     #7FFF,W10
1AAC:  AND     W1,W10,W10
1AAE:  BTSS.B  42.1
1AB0:  MOV     W1,W10
1AB2:  XOR     W3,W10,W11
1AB4:  MOV     W1,W6
1AB6:  MOV     W3,W7
1AB8:  MOV     W3,W12
1ABA:  BCLR.B  42.1
1ABC:  BCLR.B  42.0
1ABE:  RLC     W6,W6
1AC0:  SWAP    W6
1AC2:  AND     #FF,W6
1AC4:  CP0     W6
1AC6:  BRA     Z,1C0A
1AC8:  BCLR.B  42.1
1ACA:  BCLR.B  42.0
1ACC:  RLC     W7,W7
1ACE:  SWAP    W7
1AD0:  AND     #FF,W7
1AD2:  CP0     W7
1AD4:  BRA     Z,1C14
1AD6:  BCLR.B  42.1
1AD8:  BCLR.B  42.0
1ADA:  CP      W7,W6
1ADC:  BRA     Z,1C16
1ADE:  BRA     N,1C26
1AE0:  BCLR    W9.0
1AE2:  BSET    W9.1
1AE4:  SUB     W7,W6,W8
1AE6:  MOV     W7,W6
1AE8:  AND     #FF,W1
1AEA:  BSET    W1.7
1AEC:  AND     #FF,W3
1AEE:  BSET    W3.7
1AF0:  MOV     #28,W7
1AF2:  CP      W7,W8
1AF4:  BRA     N,1B18
1AF6:  BCLR.B  42.1
1AF8:  BCLR.B  42.0
1AFA:  RRC     W1,W1
1AFC:  RRC     W0,W0
1AFE:  DEC     W8,W8
1B00:  BRA     NZ,1AF6
1B02:  BRA     1B1E
1B04:  MOV     #28,W7
1B06:  CP      W7,W8
1B08:  BRA     N,1B1C
1B0A:  BCLR.B  42.1
1B0C:  BCLR.B  42.0
1B0E:  RRC     W3,W3
1B10:  RRC     W2,W2
1B12:  DEC     W8,W8
1B14:  BRA     NZ,1B0A
1B16:  BRA     1B36
1B18:  MOV     W2,W0
1B1A:  MOV     W3,W1
1B1C:  BRA     1BA4
1B1E:  BTSS    W11.F
1B20:  BRA     1B44
1B22:  BTSC    W9.4
1B24:  MOV     W12,W11
1B26:  NEG     W0,W0
1B28:  BRA     Z,1B2E
1B2A:  COM.B   W1L,W1L
1B2C:  BRA     1B30
1B2E:  NEG     W1,W1
1B30:  BTSC    W9.4
1B32:  BRA     1B8A
1B34:  BRA     1B44
1B36:  BTSS    W11.F
1B38:  BRA     1B44
1B3A:  NEG     W2,W2
1B3C:  BRA     Z,1B42
1B3E:  COM.B   W3L,W3L
1B40:  BRA     1B44
1B42:  NEG     W3,W3
1B44:  AND     #FF,W5
1B46:  BCLR.B  42.1
1B48:  BCLR.B  42.0
1B4A:  ADD     W0,W2,W0
1B4C:  ADDC.B  W1L,W3L,W1L
1B4E:  BTSC.B  42.0
1B50:  BSET    W9.3
1B52:  BTSC    W9.0
1B54:  BRA     1B68
1B56:  BTSC    W9.1
1B58:  BRA     1B5C
1B5A:  BRA     1B72
1B5C:  BTSC    W11.F
1B5E:  BRA     1B8A
1B60:  BTSC    W9.3
1B62:  BRA     1BB6
1B64:  BSET    W9.6
1B66:  BRA     1BA4
1B68:  BTSC    W11.F
1B6A:  BRA     1B8A
1B6C:  BTSC    W9.3
1B6E:  BRA     1BB6
1B70:  BRA     1BA4
1B72:  BCLR    W9.2
1B74:  BTSC    W11.F
1B76:  BRA     1B80
1B78:  MOV     W10,W11
1B7A:  BTSC    W9.3
1B7C:  BRA     1BB6
1B7E:  BRA     1BEC
1B80:  BSET    W9.4
1B82:  XOR.B   #80,W1L
1B84:  BTSC    W1.7
1B86:  BRA     1B22
1B88:  MOV     W10,W11
1B8A:  AND     #FF,W1
1B8C:  IOR      W0,  W1,W7
1B8E:  BRA     Z,1BA4
1B90:  BTSC    W1.7
1B92:  BRA     1BA4
1B94:  BCLR.B  42.1
1B96:  BCLR.B  42.0
1B98:  RLC     W0,W0
1B9A:  RLC     W1,W1
1B9C:  DEC     W6,W6
1B9E:  BTSC.B  42.1
1BA0:  BRA     1C04
1BA2:  BRA     1B90
1BA4:  BTSC    W9.0
1BA6:  MOV     W10,W11
1BA8:  BTSC    W9.1
1BAA:  MOV     W12,W11
1BAC:  BTSS    W9.5
1BAE:  BRA     1BE4
1BB0:  BTSC    W10.F
1BB2:  BSET    W0.8
1BB4:  BRA     1BEC
1BB6:  BSET.B  42.0
1BB8:  RRC.B   W1L,W1L
1BBA:  RRC     W0,W0
1BBC:  BTSC.B  42.0
1BBE:  BSET    W9.5
1BC0:  INC     W6,W6
1BC2:  BRA     Z,1C04
1BC4:  BTSS    W9.5
1BC6:  BRA     1BD8
1BC8:  INC     W0,W0
1BCA:  BRA     NZ,1BD8
1BCC:  INC.B   W1L,W1L
1BCE:  BRA     NZ,1BD8
1BD0:  RRC.B   W1L,W1L
1BD2:  RRC     W0,W0
1BD4:  INC     W6,W6
1BD6:  BRA     Z,1C04
1BD8:  BTSC    W9.0
1BDA:  MOV     W10,W11
1BDC:  BTSC    W9.1
1BDE:  MOV     W12,W11
1BE0:  BTSC.B  42.1
1BE2:  BRA     1C04
1BE4:  BTSC    W9.6
1BE6:  MOV     W10,W11
1BE8:  BTSC    W9.7
1BEA:  MOV     W12,W11
1BEC:  IOR      W0,  W1,W2
1BEE:  BRA     Z,1C36
1BF0:  BCLR    W1.7
1BF2:  SWAP    W6
1BF4:  BCLR.B  42.1
1BF6:  BCLR.B  42.0
1BF8:  RRC     W6,W6
1BFA:  XOR     W6,W1,W1
1BFC:  BSET    W1.F
1BFE:  BTSS    W11.F
1C00:  BCLR    W1.F
1C02:  BRA     1C36
1C04:  MOV     #0,W0
1C06:  MOV     #0,W1
1C08:  BRA     1C36
1C0A:  BTSC    W10.F
1C0C:  XOR     W8,W3,W3
1C0E:  MOV     W2,W0
1C10:  MOV     W3,W1
1C12:  BRA     1C36
1C14:  BRA     1C36
1C16:  AND     #FF,W3
1C18:  BSET    W3.7
1C1A:  AND     #FF,W1
1C1C:  BSET    W1.7
1C1E:  BTSC    W11.F
1C20:  BCLR    W3.7
1C22:  BSET    W9.2
1C24:  BRA     1B36
1C26:  SUB     W6,W7,W8
1C28:  AND     #FF,W1
1C2A:  BSET    W1.7
1C2C:  AND     #FF,W3
1C2E:  BSET    W3.7
1C30:  BCLR    W9.1
1C32:  BSET    W9.0
1C34:  BRA     1B04
1C36:  MOV     #12,W5
1C38:  REPEAT  #3
1C3A:  MOV     [--W15],[W5--]
1C3C:  MOV     [--W15],W5
1C3E:  RETURN  
*
1C6C:  MOV     W5,[W15++]
1C6E:  MOV     W6,[W15++]
1C70:  MOV     #8E,W1
1C72:  BCLR    W6.0
1C74:  BTSS    W0.F
1C76:  BRA     1C7E
1C78:  BSET    W6.0
1C7A:  NEG     W0,W0
1C7C:  BRA     1C7E
1C7E:  CP0     W0
1C80:  BRA     Z,1CAA
1C82:  BTSC    W0.F
1C84:  BRA     1C8E
1C86:  BCLR.B  42.0
1C88:  RLC     W0,W0
1C8A:  DEC     W1,W1
1C8C:  BRA     1C82
1C8E:  SWAP    W1
1C90:  BCLR.B  42.0
1C92:  RRC     W1,W1
1C94:  BCLR    W0.F
1C96:  SWAP    W0
1C98:  XOR.B   W0L,W1L,W1L
1C9A:  AND.B   #0,W0L
1C9C:  BTSC    W6.0
1C9E:  BSET    W1.F
1CA0:  BRA     1CB0
1CA2:  MOV.B   W1L,W0L
1CA4:  BSET    W1.7
1CA6:  AND.B   #0,W1L
1CA8:  BRA     1CB0
1CAA:  CLR     W0
1CAC:  CLR     W1
1CAE:  BRA     1CB0
1CB0:  MOV     [--W15],W6
1CB2:  MOV     [--W15],W5
1CB4:  RETURN  
....................  
.................... #list 
....................  
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 1 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B5  //Limit Switch1 
.................... #pin_select INT2 = PIN_B4  //Limit Switch2 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
.................... #pin_select OC1 = PIN_B6   //ENA1 
.................... #pin_select OC2 = PIN_B7   //ENA2 
.................... #pin_select IC1 = PIN_B0   //Encoder1_A 
.................... #pin_select IC2 = PIN_B1   //Encoder1_B 
.................... #pin_select IC3 = PIN_B2   //Encoder2_A 
.................... #pin_select IC4 = PIN_B3   //B3 = Encoder2_B 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
*
2446:  MOV     W5,[W15++]
2448:  MOV     W6,[W15++]
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
244A:  PUSH    ADC
244C:  POP     ADE
244E:  MOV     ADE,W0
2450:  MOV.B   [W0],W5L
2452:  SE      W5,W5
2454:  CP0     W5
2456:  BRA     Z,245C
2458:  INC     0ADE
245A:  BRA     244E
....................    return(sc - s); 
245C:  MOV     ADE,W4
245E:  MOV     ADC,W3
2460:  SUB     W4,W3,W0
2462:  MOV     [--W15],W6
2464:  MOV     [--W15],W5
2466:  RETURN  
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
*
0F94:  MOV     W5,[W15++]
.................... { 
....................    node_t *result; 
....................    result =ptr; 
0F96:  PUSH    B30
0F98:  POP     B32
....................    result->size=size; 
0F9A:  MOV     #0,W0
0F9C:  ADD     B32,W0
0F9E:  MOV     W0,W5
0FA0:  MOV     B2E,W4
0FA2:  MOV     W4,[W5+#0]
....................    result->next = NULL; 
0FA4:  MOV     #2,W0
0FA6:  ADD     B32,W0
0FA8:  MOV     W0,W5
0FAA:  CLR.B   [W5]
0FAC:  MOV.B   #0,W0L
0FAE:  MOV.B   W0L,[W5+#1]
....................    return result; 
0FB0:  PUSH    B32
0FB2:  POP     0
0FB4:  MOV     [--W15],W5
0FB6:  RETURN  
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
*
0E96:  MOV     W5,[W15++]
.................... { 
....................    node->size=size; 
0E98:  MOV     #0,W0
0E9A:  ADD     B36,W0
0E9C:  MOV     W0,W5
0E9E:  MOV     B38,W4
0EA0:  MOV     W4,[W5+#0]
0EA2:  MOV     [--W15],W5
0EA4:  RETURN  
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
*
0FB8:  MOV     W5,[W15++]
.................... { 
....................     if (place->next==NULL) 
0FBA:  MOV     #2,W0
0FBC:  ADD     B24,W0
0FBE:  MOV     [W0],W5
0FC0:  CP0     W5
0FC2:  BRA     NZ,FD2
....................        node->next= NULL; 
0FC4:  MOV     #2,W0
0FC6:  ADD     B26,W0
0FC8:  MOV     W0,W5
0FCA:  CLR.B   [W5]
0FCC:  MOV.B   #0,W0L
0FCE:  MOV.B   W0L,[W5+#1]
0FD0:  BRA     FDE
....................     else 
....................        node->next=place->next; 
0FD2:  MOV     #2,W0
0FD4:  ADD     B26,W0
0FD6:  MOV     W0,W5
0FD8:  MOV     #2,W0
0FDA:  ADD     B24,W0
0FDC:  MOV     [W0],[W5]
....................     place->next=node; 
0FDE:  MOV     #2,W0
0FE0:  ADD     B24,W0
0FE2:  MOV     W0,W5
0FE4:  MOV     B26,W4
0FE6:  MOV     W4,[W5+#0]
0FE8:  MOV     [--W15],W5
0FEA:  RETURN  
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
*
0EA6:  MOV     W5,[W15++]
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
0EA8:  PUSH    806
0EAA:  POP     B36
0EAC:  MOV     #2,W0
0EAE:  ADD     B36,W0
0EB0:  MOV     [W0],W5
0EB2:  MOV     B34,W4
0EB4:  CP      W4,W5
0EB6:  BRA     Z,EC2
0EB8:  MOV     #2,W0
0EBA:  ADD     B36,W0
0EBC:  MOV     [W0],[W15++]
0EBE:  POP     B36
0EC0:  BRA     EAC
....................    ptr->next=node->next; 
0EC2:  MOV     #2,W0
0EC4:  ADD     B36,W0
0EC6:  MOV     W0,W5
0EC8:  MOV     #2,W0
0ECA:  ADD     B34,W0
0ECC:  MOV     [W0],[W5]
....................    node=NULL; 
0ECE:  CLR     B34
0ED0:  MOV     [--W15],W5
0ED2:  RETURN  
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
0ED4:  MOV     W5,[W15++]
0ED6:  MOV     W6,[W15++]
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
0ED8:  PUSH    806
0EDA:  POP     B1E
....................    while(node!=NULL) 
0EDC:  CP0     B1E
0EDE:  BRA     Z,F4C
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
0EE0:  MOV     #0,W0
0EE2:  ADD     B1E,W0
0EE4:  MOV     [W0],W5
0EE6:  BTSC    W5.F
0EE8:  BRA     F42
....................       { 
....................          nsize=node->size; 
0EEA:  MOV     #0,W0
0EEC:  ADD     B1E,W0
0EEE:  MOV     [W0],[W15++]
0EF0:  POP     B22
....................          temp=(unsigned int16)node->next; 
0EF2:  MOV     #2,W0
0EF4:  ADD     B1E,W0
0EF6:  MOV     [W0],[W15++]
0EF8:  POP     B20
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
0EFA:  MOV     #0,W0
0EFC:  ADD     B20,W0
0EFE:  MOV     [W0],W5
0F00:  BTSC    W5.F
0F02:  BRA     F38
0F04:  MOV     B1E,W0
0F06:  ADD     B22,W0
0F08:  MOV     W0,W6
0F0A:  ADD     W6,#4,W6
0F0C:  MOV     W6,W0
0F0E:  CP      B20
0F10:  BRA     NZ,F38
....................          { 
....................             nextsize=temp->size; 
0F12:  MOV     #0,W0
0F14:  ADD     B20,W0
0F16:  MOV     [W0],[W15++]
0F18:  POP     B24
....................             nsize+=nextsize+sizeof(node_t); 
0F1A:  MOV     B24,W4
0F1C:  ADD     W4,#4,W4
0F1E:  MOV     W4,W0
0F20:  ADD     B22
....................             remove_node(temp); 
0F22:  PUSH    B20
0F24:  POP     B34
0F26:  CALL    EA6
....................             update_node(node,nsize); 
0F2A:  PUSH    B1E
0F2C:  POP     B36
0F2E:  PUSH    B22
0F30:  POP     B38
0F32:  CALL    E96
....................          } 
0F36:  BRA     F40
....................          else 
....................          node=node->next; 
0F38:  MOV     #2,W0
0F3A:  ADD     B1E,W0
0F3C:  MOV     [W0],[W15++]
0F3E:  POP     B1E
....................       } 
0F40:  BRA     F4A
....................       else 
....................       node=node->next; 
0F42:  MOV     #2,W0
0F44:  ADD     B1E,W0
0F46:  MOV     [W0],[W15++]
0F48:  POP     B1E
0F4A:  BRA     EDC
....................    } 
0F4C:  MOV     [--W15],W6
0F4E:  MOV     [--W15],W5
0F50:  RETURN  
.................... } 
....................  
.................... char *malloc(size_t size) 
*
0FEC:  MOV     W5,[W15++]
0FEE:  MOV     W6,[W15++]
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
0FF0:  MOV     B08,W0
0FF2:  AND     W0,#1,W0
0FF4:  CP0     W0
0FF6:  BRA     Z,FFA
....................       size++; 
0FF8:  INC     0B08
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
0FFA:  PUSH    806
0FFC:  POP     B0A
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
0FFE:  CP0     B0A
1000:  BRA     Z,1084
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
1002:  MOV     #0,W0
1004:  ADD     B0A,W0
1006:  MOV     [W0],W5
1008:  BTSC    W5.F
100A:  BRA     107A
100C:  MOV     #0,W0
100E:  ADD     B0A,W0
1010:  MOV     [W0],W6
1012:  MOV     B08,W4
1014:  CP      W4,W6
1016:  BRA     GTU,107A
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
1018:  MOV     #0,W0
101A:  ADD     B0A,W0
101C:  MOV     [W0],[W15++]
101E:  POP     B0E
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
1020:  MOV     B08,W4
1022:  ADD     W4,#4,W4
1024:  MOV     W4,W0
1026:  MOV     B0E,W4
1028:  CP      W4,W0
102A:  BRA     LEU,1068
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
102C:  MOV     B0E,W4
102E:  MOV     B08,W3
1030:  SUB     W4,W3,W5
1032:  SUB     W5,#4,W5
1034:  MOV     B0A,W4
1036:  ADD     W4,#4,W4
1038:  MOV     W4,W6
103A:  MOV     W6,W0
103C:  ADD     B08,W0
103E:  MOV     W0,W6
1040:  MOV     W5,B2E
1042:  MOV     W6,B30
1044:  CALL    F94
1048:  MOV     W0,B0C
....................             insert_node_after(node,new); 
104A:  PUSH    B0A
104C:  POP     B24
104E:  PUSH    B0C
1050:  POP     B26
1052:  CALL    FB8
....................             update_node(node,size+_MEMMGMT_CSIZE); 
1056:  MOV     #8000,W4
1058:  MOV     B08,W3
105A:  ADD     W3,W4,W5
105C:  PUSH    B0A
105E:  POP     B36
1060:  MOV     W5,B38
1062:  CALL    E96
....................          } 
1066:  BRA     1078
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
1068:  MOV     #8000,W4
106A:  MOV     B0E,W3
106C:  ADD     W3,W4,W5
106E:  PUSH    B0A
1070:  POP     B36
1072:  MOV     W5,B38
1074:  CALL    E96
....................          //end if 
....................          break; 
1078:  BRA     1084
....................       }//end if 
....................       node=node->next; 
107A:  MOV     #2,W0
107C:  ADD     B0A,W0
107E:  MOV     [W0],[W15++]
1080:  POP     B0A
1082:  BRA     FFE
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
1084:  CP0     B0A
1086:  BRA     NZ,108E
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
1088:  CLR     0
108A:  BRA     1098
....................    } 
108C:  BRA     1098
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
108E:  MOV     B0A,W4
1090:  ADD     W4,#4,W4
1092:  MOV     W4,W0
1094:  MOV     W0,0
1096:  BRA     1098
1098:  MOV     [--W15],W6
109A:  MOV     [--W15],W5
109C:  RETURN  
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
*
0F52:  MOV     W5,[W15++]
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
0F54:  CP0     B00
0F56:  BRA     NZ,F5C
....................       return; 
0F58:  BRA     F90
0F5A:  BRA     F8C
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
0F5C:  MOV     B00,W4
0F5E:  SUB     W4,#4,W0
0F60:  MOV     W0,B02
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
0F62:  MOV     #0,W0
0F64:  ADD     B02,W0
0F66:  MOV     [W0],W5
0F68:  BTSS    W5.F
0F6A:  BRA     F88
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
0F6C:  MOV     #0,W0
0F6E:  ADD     B02,W0
0F70:  MOV     [W0],W5
0F72:  MOV     #8000,W4
0F74:  SUB     W5,W4,W0
0F76:  MOV     W0,B04
....................          update_node(node,nsize); 
0F78:  PUSH    B02
0F7A:  POP     B36
0F7C:  PUSH    B04
0F7E:  POP     B38
0F80:  CALL    E96
....................          ptr=NULL; 
0F84:  CLR     B00
....................  
....................       } 
0F86:  BRA     F8C
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
0F88:  CLR     B00
....................          return; 
0F8A:  BRA     F90
....................       } 
....................    } 
....................    traverse(); 
0F8C:  CALL    ED4
0F90:  MOV     [--W15],W5
0F92:  RETURN  
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "BL_support.h" 
.................... /******************************************************************************/ 
.................... /* File:    BL_Support.h													  */ 
.................... /* Author:  Dr.Santi Nuratch												  */ 
.................... /*          Embedded Computing and Control Lab., INC-KMUTT 				      */ 
.................... /* Created on 22 September 2016, 13:14										  */ 
.................... /******************************************************************************/ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... /****************************************************************************/ 
.................... // o/p pins  LED 
.................... #define  IN1  PIN_A0 
.................... #define  IN2  PIN_A1   
.................... #define  IN3  PIN_A2   
.................... #define  IN4  PIN_A4   
....................  
.................... // i/p pins  PBSW 
.................... #define  SW0  PIN_B1   //Encoder1B 
.................... #define  SW1  PIN_B3   //Encoder2B 
.................... #define  SW2  PIN_B6 
.................... #define  SW3  PIN_B7 
....................  
.................... // ADC  or  i/o pins if not use ADC 
.................... #define  AX0  PIN_A0 
.................... #define  AX1  PIN_A1 
.................... #define  AX2  PIN_B0  // RP0 remap pin 
.................... #define  AX3  PIN_B1  // RP1 remap pin 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "CDATPIC24.H" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #ifndef BITWISE_LIB_C_SRC 
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                 Bitwise Library functions (Passed by value) 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                            FUNCTION : BitSet  
.................... // 
.................... // Description : Set a specified bit in 16-bit unsigned data to logic 1, other   
.................... //               bits are not changed 
.................... // Arguments   : "dat"     is the data whose a bit will be set 
.................... //               "bitPos"  is a specified bit position in "dat" which will be set,  
.................... //                            0 <= bitPos <= 15  (bit 0 is LSB, bit 15 is MSB)  
.................... // Returns     : value of "dat" with a bit at position "bitPos" was set to logic 1 
.................... /****************************************************************************/ 
....................  
.................... int16u BitSet (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitClear (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitInvt (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitTest (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
.................... /*****************************************************************************/ 
.................... //                 Bitwise Library functions (Passed by address) 
.................... /*****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                            FUNCTION : BitSetP  
.................... // 
.................... // Description : Set a specified bit in 16-bit unsigned variable to logic 1,    
.................... //               other bits are not changed 
.................... // Arguments   : "datPtr"  is the address of a variable whose a bit will be set 
.................... //               "bitPos"  is a specified bit position in the variable which   
.................... //                         will be set,   0 <= bitPos <= 15   
.................... //                         (bit 0 is LSB, bit 15 is MSB)  
.................... // Returns     : none 
.................... /****************************************************************************/ 
....................  
.................... void BitSetP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... void BitClearP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... void BitInvtP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitTestP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                      PROTOTYPES OF LOCAL FUNCTIONS                     **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED VARIABLES                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                            GLOBAL VARIABLES                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED FUNCTIONS                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... int16u BitSet (int16u dat, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	dat = dat | (1<< bitPos); 
.................... 	return dat; 
.................... } 
....................  
.................... int16u BitClear (int16u dat, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	dat = dat & (~(1<< bitPos)); 
.................... 	return dat; 
.................... } 
....................  
.................... int16u BitInvt (int16u dat, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	dat = dat ^ (1 << bitPos); 
.................... 	return dat; 
.................... } 
....................  
.................... int16u BitTest (int16u dat, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	dat = (dat & (1 << bitPos)) >> bitPos; 
.................... 	return dat; 
.................... } 
....................  
.................... void BitSetP (int16u *datPtr, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	*datPtr = *datPtr | (1<< bitPos); 
.................... 	return; 
.................... } 
....................  
.................... void BitClearP (int16u *datPtr, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	*datPtr = *datPtr & (~(1 << bitPos)); 
.................... 	return; 
.................... } 
....................  
.................... void BitInvtP (int16u *datPtr, int16u bitPos) 
.................... { 
.................... 	bitPos = bitPos % 16; 
.................... 	*datPtr = *datPtr ^ (1 << bitPos); 
.................... 	return ; 
.................... } 
....................  
.................... int16u BitTestP (int16u *datPtr, int16u bitPos) 
.................... { 
.................... 	int16u result; 
.................... 	bitPos = bitPos % 16; 
.................... 	result = (*datPtr & (1<< bitPos)) >>bitPos; 
.................... 	return result; 
.................... } 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             LOCAL FUNCTIONS                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                                 EOF                                    **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #import(file="CONTROL_PID.o") 
.................... /* 
.................... *************************** C SOURCE FILE ************************************ 
.................... project   : 
.................... filename  : CONTROL_PID.C 
.................... version   : 2 
.................... date      : 
.................... ****************************************************************************** 
.................... Copyright (c) 20xx 
.................... All rights reserved. 
.................... ****************************************************************************** 
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #define CONTROL_PID_C_SRC 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             MODULES USED                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "CONTROL_PID.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONTROL_PID.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONTROL_PID_INCLUDED 
.................... #define  CONTROL_PID_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
.................... #include "CONFIG_PIC24.H" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
*
0DFC:  CLR     32
0DFE:  MOV     #E08,W3
0E00:  ADD     W3,W0,W0
0E02:  TBLRDL.B[W0],W0L
0E04:  CLR.B   1
0E06:  RETURN  
0E08:  DATA    0D,0A,00
0E0A:  DATA    20,78,00
0E0C:  DATA    20,3D,00
0E0E:  DATA    3D,20,00
0E10:  DATA    25,64,00
0E12:  DATA    00,00,00
0E14:  CLR     32
0E16:  MOV     #E20,W3
0E18:  ADD     W3,W0,W0
0E1A:  TBLRDL.B[W0],W0L
0E1C:  CLR.B   1
0E1E:  RETURN  
0E20:  DATA    0D,0A,00
0E22:  DATA    20,79,00
0E24:  DATA    20,3D,00
0E26:  DATA    3D,20,00
0E28:  DATA    25,64,00
0E2A:  DATA    00,00,00
*
172A:  MOV     W5,[W15++]
172C:  MOV     W6,[W15++]
172E:  MOV     W3,W4
1730:  MOV     W3,W6
1732:  BCLR.B  42.0
1734:  ASR     W4,#4,W4
1736:  MOV     #7FF,W5
1738:  AND     W5,W4,W4
173A:  BRA     NZ,1742
173C:  MUL.UU  W0,#0,W0
173E:  CLR     W2
1740:  BRA     1768
1742:  SUB     #380,W4
1744:  AND     #F,W3
1746:  MOV     #3,W7
1748:  BCLR.B  42.0
174A:  RLC     W0,W0
174C:  RLC     W1,W1
174E:  RLC     W2,W2
1750:  RLC     W3,W3
1752:  DEC     W7,W7
1754:  BRA     NZ,1748
1756:  MOV     W1,W0
1758:  MOV     W2,W1
175A:  BCLR    W3.7
175C:  SWAP    W4
175E:  BCLR.B  42.0
1760:  RRC     W4,W4
1762:  BTSC    W6.F
1764:  BSET    W4.F
1766:  XOR     W4,W3,W2
1768:  MOV     [--W15],W6
176A:  MOV     [--W15],W5
176C:  RETURN  
*
1A06:  MOV     W5,[W15++]
1A08:  MOV     #C,W5
1A0A:  REPEAT  #5
1A0C:  MOV     [W5++],[W15++]
1A0E:  MOV     W3,W8
1A10:  MOV     W2,W7
1A12:  MOV     W1,W6
1A14:  MOV     W0,W5
1A16:  MOV     W3,W9
1A18:  MOV     #473,W11
1A1A:  ASR     W3,#4,W3
1A1C:  MOV     #7FF,W10
1A1E:  AND     W10,W3,W3
1A20:  SUB     W11,W3,W11
1A22:  AND     #1F,W8
1A24:  BSET    W8.4
1A26:  CLR     W0
1A28:  CLR     W1
1A2A:  CLR     W2
1A2C:  CLR     W3
1A2E:  BCLR.B  42.0
1A30:  RRC     W8,W8
1A32:  RRC     W7,W7
1A34:  RRC     W6,W6
1A36:  RRC     W5,W5
1A38:  RRC     W3,W3
1A3A:  RRC     W2,W2
1A3C:  RRC     W1,W1
1A3E:  RRC     W0,W0
1A40:  DEC     W11,W11
1A42:  BRA     NZ,1A2E
1A44:  BTSS    W9.F
1A46:  BRA     1A52
1A48:  NEG     W0,W0
1A4A:  COM     W1,W1
1A4C:  COM     W2,W2
1A4E:  COM     W3,W3
1A50:  BRA     1A52
1A52:  MOV     #16,W5
1A54:  REPEAT  #5
1A56:  MOV     [--W15],[W5--]
1A58:  MOV     [--W15],W5
1A5A:  RETURN  
1A5C:  MOV     W5,[W15++]
1A5E:  MOV     W6,[W15++]
1A60:  MOV     #8E,W1
1A62:  CP0     W0
1A64:  BRA     Z,1A8A
1A66:  BTSC    W0.F
1A68:  BRA     1A72
1A6A:  BCLR.B  42.0
1A6C:  RLC     W0,W0
1A6E:  DEC     W1,W1
1A70:  BRA     1A66
1A72:  SWAP    W1
1A74:  BCLR.B  42.0
1A76:  RRC     W1,W1
1A78:  BCLR    W0.F
1A7A:  SWAP    W0
1A7C:  XOR.B   W0L,W1L,W1L
1A7E:  AND.B   #0,W0L
1A80:  BRA     1A90
1A82:  MOV.B   W1L,W0L
1A84:  BSET    W1.7
1A86:  AND.B   #0,W1L
1A88:  BRA     1A90
1A8A:  CLR     W0
1A8C:  CLR     W1
1A8E:  BRA     1A90
1A90:  MOV     [--W15],W6
1A92:  MOV     [--W15],W5
1A94:  RETURN  
*
1C40:  MOV     W0,W2
1C42:  MOV     W1,W3
1C44:  MOV.B   W1L,W0L
1C46:  SWAP    W0
1C48:  BSET    W0.F
1C4A:  RLC     W1,W1
1C4C:  SWAP    W1
1C4E:  ZE      W1,W1
1C50:  MOV     #8E,W4
1C52:  SUB.B   W4L,W1L,W1L
1C54:  BRA     Z,1C62
1C56:  CP0     W0
1C58:  BRA     Z,1C62
1C5A:  BCLR.B  42.0
1C5C:  RRC     W0,W0
1C5E:  DEC     W1,W1
1C60:  BRA     NZ,1C56
1C62:  BTSS    W3.F
1C64:  BRA     1C6A
1C66:  NEG     W0,W0
1C68:  BRA     1C6A
1C6A:  RETURN  
*
1CB6:  MOV     W5,[W15++]
1CB8:  MOV     W6,[W15++]
1CBA:  MOV     W7,[W15++]
1CBC:  XOR     W1,W3,W4
1CBE:  BTSS    W4.F
1CC0:  BRA     1CCE
1CC2:  BCLR.B  42.0
1CC4:  BCLR.B  42.1
1CC6:  BTSS    W1.F
1CC8:  BRA     1D16
1CCA:  BSET.B  42.0
1CCC:  BRA     1D16
1CCE:  MOV     W1,W4
1CD0:  MOV     W0,W5
1CD2:  MOV     W3,W6
1CD4:  MOV     W2,W7
1CD6:  RLC     W1,W1
1CD8:  SWAP    W1
1CDA:  RLC     W3,W3
1CDC:  SWAP    W3
1CDE:  SUB.B   W3L,W1L,W1L
1CE0:  BRA     Z,1CEC
1CE2:  BTSS    W4.F
1CE4:  BRA     1D16
1CE6:  MOV     #1,W0
1CE8:  XOR.B   42
1CEA:  BRA     1D16
1CEC:  MOV.B   W4L,W1L
1CEE:  MOV.B   W6L,W3L
1CF0:  BCLR    W1.7
1CF2:  BCLR    W3.7
1CF4:  SUB.B   W3L,W1L,W1L
1CF6:  BRA     Z,1D02
1CF8:  BTSS    W4.F
1CFA:  BRA     1D16
1CFC:  MOV     #1,W0
1CFE:  XOR.B   42
1D00:  BRA     1D16
1D02:  SUB     W7,W5,W1
1D04:  BRA     Z,1D10
1D06:  BTSS    W4.F
1D08:  BRA     1D16
1D0A:  MOV     #1,W0
1D0C:  XOR.B   42
1D0E:  BRA     1D16
1D10:  BCLR.B  42.0
1D12:  BRA     1D16
1D14:  BRA     1D16
1D16:  MOV     [--W15],W7
1D18:  MOV     [--W15],W6
1D1A:  MOV     [--W15],W5
1D1C:  RETURN  
*
2468:  MOV     W5,[W15++]
246A:  MOV     #C,W5
246C:  REPEAT  #3
246E:  MOV     [W5++],[W15++]
2470:  BTSS    W0.F
2472:  BRA     248C
2474:  NEG     W0,W0
2476:  BSET    W4.8
2478:  BTSS    W4.F
247A:  BRA     248C
247C:  MOV     W0,[W15++]
247E:  MOV     #2D,W0
2480:  BTSC.B  223.1
2482:  BRA     2480
2484:  MOV     W0,224
2486:  MOV     [--W15],W0
2488:  BCLR    W4.8
248A:  DEC.B   0008
248C:  CLR     W5
248E:  MOV     W0,W7
2490:  MOV     W4,W9
2492:  BCLR    W4.F
2494:  CP0.B   W4L
2496:  BRA     NZ,24A4
2498:  BTSC    W9.F
249A:  BRA     24A0
249C:  MOV     #0,W5
249E:  BRA     24BE
24A0:  MOV     #0,W5
24A2:  BRA     24BE
24A4:  SUB.B   W4L,#6,W5L
24A6:  BRA     NC,24BC
24A8:  MOV     #30,W0
24AA:  BTSS    W9.F
24AC:  MOV     #20,W0
24AE:  BTSC.B  223.1
24B0:  BRA     24AE
24B2:  MOV     W0,224
24B4:  DEC     W5,W5
24B6:  BRA     NN,24AE
24B8:  MOV     #5,W5
24BA:  BRA     24BE
24BC:  MOV     W4,W5
24BE:  MOV     #6,W4
24C0:  BTSC    W5.8
24C2:  INC     W4,W4
24C4:  BSET    W5.E
24C6:  BTSC    W9.F
24C8:  BSET    W5.F
24CA:  MOV     #2710,W8
24CC:  REPEAT  #11
24CE:  DIV.U   W7,W8
24D0:  CALL    2514
24D4:  MOV     W1,W7
24D6:  MOV     #3E8,W8
24D8:  REPEAT  #11
24DA:  DIV.U   W7,W8
24DC:  CALL    2514
24E0:  MOV     W1,W7
24E2:  MOV     #64,W8
24E4:  REPEAT  #11
24E6:  DIV.U   W7,W8
24E8:  CALL    2514
24EC:  MOV     W1,W7
24EE:  MOV     #A,W8
24F0:  REPEAT  #11
24F2:  DIV.U   W7,W8
24F4:  CALL    2514
24F8:  BTSS    W9.8
24FA:  BRA     2506
24FC:  MOV     #2D,W0
24FE:  BTSC.B  223.1
2500:  BRA     24FE
2502:  MOV     W0,224
2504:  BCLR    W9.8
2506:  MOV     #30,W0
2508:  ADD.B   W1L,W0L,W0L
250A:  MOV     W0,2A
250C:  BTSC.B  223.1
250E:  BRA     250C
2510:  MOV     W0,224
2512:  BRA     2554
2514:  MOV     #30,W6
2516:  CP0     W0
2518:  BRA     NZ,2536
251A:  BTSS    W5.E
251C:  BRA     254A
251E:  DEC     W4,W4
2520:  CP.B    W4L,W5L
2522:  BRA     Z,2528
2524:  BTSC.B  42.0
2526:  RETURN  
2528:  CP0     W0
252A:  BRA     NZ,2536
252C:  BTSS    W5.E
252E:  BRA     254A
2530:  BTSS    W5.F
2532:  MOV     #20,W6
2534:  BRA     254A
2536:  BCLR    W5.E
2538:  BTSS    W9.8
253A:  BRA     254A
253C:  MOV     W0,W10
253E:  MOV     #2D,W0
2540:  BTSC.B  223.1
2542:  BRA     2540
2544:  MOV     W0,224
2546:  BCLR    W9.8
2548:  MOV     W10,W0
254A:  ADD.B   W6L,W0L,W0L
254C:  BTSC.B  223.1
254E:  BRA     254C
2550:  MOV     W0,224
2552:  RETURN  
2554:  MOV     #12,W5
2556:  REPEAT  #3
2558:  MOV     [--W15],[W5--]
255A:  MOV     [--W15],W5
255C:  RETURN  
....................  
.................... #list 
....................  
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 1 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B5  //Limit Switch1 
.................... #pin_select INT2 = PIN_B4  //Limit Switch2 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
.................... #pin_select OC1 = PIN_B6   //ENA1 
.................... #pin_select OC2 = PIN_B7   //ENA2 
.................... #pin_select IC1 = PIN_B0   //Encoder1_A 
.................... #pin_select IC2 = PIN_B1   //Encoder1_B 
.................... #pin_select IC3 = PIN_B2   //Encoder2_A 
.................... #pin_select IC4 = PIN_B3   //B3 = Encoder2_B 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "BL_support.h" 
.................... /******************************************************************************/ 
.................... /* File:    BL_Support.h													  */ 
.................... /* Author:  Dr.Santi Nuratch												  */ 
.................... /*          Embedded Computing and Control Lab., INC-KMUTT 				      */ 
.................... /* Created on 22 September 2016, 13:14										  */ 
.................... /******************************************************************************/ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... /****************************************************************************/ 
.................... // o/p pins  LED 
.................... #define  IN1  PIN_A0 
.................... #define  IN2  PIN_A1   
.................... #define  IN3  PIN_A2   
.................... #define  IN4  PIN_A4   
....................  
.................... // i/p pins  PBSW 
.................... #define  SW0  PIN_B1   //Encoder1B 
.................... #define  SW1  PIN_B3   //Encoder2B 
.................... #define  SW2  PIN_B6 
.................... #define  SW3  PIN_B7 
....................  
.................... // ADC  or  i/o pins if not use ADC 
.................... #define  AX0  PIN_A0 
.................... #define  AX1  PIN_A1 
.................... #define  AX2  PIN_B0  // RP0 remap pin 
.................... #define  AX3  PIN_B1  // RP1 remap pin 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "CDATPIC24.H" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #ifndef CONTROL_PID_C_SRC 
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "BITWISE_LIB.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : BITWISE_LIB.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  BITWISE_LIB_INCLUDED 
.................... #define  BITWISE_LIB_INCLUDED 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include "CONFIG_PIC24.H"   
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 1 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B5  //Limit Switch1 
.................... #pin_select INT2 = PIN_B4  //Limit Switch2 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
.................... #pin_select OC1 = PIN_B6   //ENA1 
.................... #pin_select OC2 = PIN_B7   //ENA2 
.................... #pin_select IC1 = PIN_B0   //Encoder1_A 
.................... #pin_select IC2 = PIN_B1   //Encoder1_B 
.................... #pin_select IC3 = PIN_B2   //Encoder2_A 
.................... #pin_select IC4 = PIN_B3   //B3 = Encoder2_B 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... #include <stdio.h> 
.................... #include <stdlibm.h> 
.................... #include <string.h> 
.................... #include <stdint.h> 
.................... #include "BL_support.h" 
.................... /****************************************************************************/ 
.................... // o/p pins  LED 
.................... #define  IN1  PIN_A0 
.................... #define  IN2  PIN_A1   
.................... #define  IN3  PIN_A2   
.................... #define  IN4  PIN_A4   
....................  
.................... // i/p pins  PBSW 
.................... #define  SW0  PIN_B1   //Encoder1B 
.................... #define  SW1  PIN_B3   //Encoder2B 
.................... #define  SW2  PIN_B6 
.................... #define  SW3  PIN_B7 
....................  
.................... // ADC  or  i/o pins if not use ADC 
.................... #define  AX0  PIN_A0 
.................... #define  AX1  PIN_A1 
.................... #define  AX2  PIN_B0  // RP0 remap pin 
.................... #define  AX3  PIN_B1  // RP1 remap pin 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "CDATPIC24.H" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #ifndef BITWISE_LIB_C_SRC 
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                 Bitwise Library functions (Passed by value) 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                            FUNCTION : BitSet  
.................... // 
.................... // Description : Set a specified bit in 16-bit unsigned data to logic 1, other   
.................... //               bits are not changed 
.................... // Arguments   : "dat"     is the data whose a bit will be set 
.................... //               "bitPos"  is a specified bit position in "dat" which will be set,  
.................... //                            0 <= bitPos <= 15  (bit 0 is LSB, bit 15 is MSB)  
.................... // Returns     : value of "dat" with a bit at position "bitPos" was set to logic 1 
.................... /****************************************************************************/ 
....................  
.................... int16u BitSet (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitClear (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitInvt (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitTest (int16u dat, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
.................... /*****************************************************************************/ 
.................... //                 Bitwise Library functions (Passed by address) 
.................... /*****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                            FUNCTION : BitSetP  
.................... // 
.................... // Description : Set a specified bit in 16-bit unsigned variable to logic 1,    
.................... //               other bits are not changed 
.................... // Arguments   : "datPtr"  is the address of a variable whose a bit will be set 
.................... //               "bitPos"  is a specified bit position in the variable which   
.................... //                         will be set,   0 <= bitPos <= 15   
.................... //                         (bit 0 is LSB, bit 15 is MSB)  
.................... // Returns     : none 
.................... /****************************************************************************/ 
....................  
.................... void BitSetP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... void BitClearP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... void BitInvtP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... int16u BitTestP (int16u *datPtr, int16u bitPos); 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
.................... #include "EVENT_DRIVEN_CCS.H" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : EVENT_DRIVEN_CCS.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  EVENT_DRIVEN_CCS_INCLUDED 
.................... #define  EVENT_DRIVEN_CCS_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
.................... #include "CONFIG_PIC24.H" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 1 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B5  //Limit Switch1 
.................... #pin_select INT2 = PIN_B4  //Limit Switch2 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
.................... #pin_select OC1 = PIN_B6   //ENA1 
.................... #pin_select OC2 = PIN_B7   //ENA2 
.................... #pin_select IC1 = PIN_B0   //Encoder1_A 
.................... #pin_select IC2 = PIN_B1   //Encoder1_B 
.................... #pin_select IC3 = PIN_B2   //Encoder2_A 
.................... #pin_select IC4 = PIN_B3   //B3 = Encoder2_B 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... #include <stdio.h> 
.................... #include <stdlibm.h> 
.................... #include <string.h> 
.................... #include <stdint.h> 
.................... #include "BL_support.h" 
.................... /****************************************************************************/ 
.................... // o/p pins  LED 
.................... #define  IN1  PIN_A0 
.................... #define  IN2  PIN_A1   
.................... #define  IN3  PIN_A2   
.................... #define  IN4  PIN_A4   
....................  
.................... // i/p pins  PBSW 
.................... #define  SW0  PIN_B1   //Encoder1B 
.................... #define  SW1  PIN_B3   //Encoder2B 
.................... #define  SW2  PIN_B6 
.................... #define  SW3  PIN_B7 
....................  
.................... // ADC  or  i/o pins if not use ADC 
.................... #define  AX0  PIN_A0 
.................... #define  AX1  PIN_A1 
.................... #define  AX2  PIN_B0  // RP0 remap pin 
.................... #define  AX3  PIN_B1  // RP1 remap pin 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
....................  
.................... #include "CDATPIC24.H" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
.................... #include "EVENT_TYPE_CCS.H" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : EVENT_TYPE_CCS.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  EVENT_TYPE_CCS_INCLUDED 
.................... #define  EVENT_TYPE_CCS_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... typedef enum 
.................... { 
....................     EV_NULL, 
....................     EV_TIMER1, 
....................     EV_TIMER2, 
....................     EV_TIMER3, 
....................     EV_STMR0, 
....................     EV_STMR1, 
....................     EV_STMR2, 
....................     EV_STMR3, 
....................     EV_STMR4, 
....................     EV_SW0, 
....................     EV_SW1, 
....................     EV_SW2, 
....................     EV_SW3, 
....................     EV_TBE1, 
....................     EV_RDA1, 
....................     EV_OC1, 
....................     EV_OC2, 
....................     EV_IC1, 
....................     EV_IC2, 
....................     EV_EXT0, 
....................     EV_EXT1, 
....................     EV_EXT2 
.................... } EV_TYPE; 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #ifndef EVENT_TYPE_CCS_C_SRC 
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /***********    Macro for Declare and Define Memory Blocks ******************/ 
....................  
.................... #define DECLARE_MEM(BLOCK_TYPE_DEF, MEM_ARRAY, STRUCT_Q_ARRAY, N_BLOCK); \ 
.................... PTR_STRUCT STRUCT_Q_ARRAY[N_BLOCK]; \ 
.................... BLOCK_TYPE_DEF MEM_ARRAY[N_BLOCK]; 
....................  
.................... /****************************************************************************/ 
....................  
.................... // Queue error codes 
.................... #define Q_OK 0 
.................... #define Q_FULL 1 
.................... #define Q_EMPLY 2 
....................  
.................... //timer mode 
.................... #define SINGLE 0 
.................... #define REPEAT 1 
....................  
.................... //timer enable, disable 
.................... #define ON 1 
.................... #define OFF 0 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //Data type for Tick Counter 
.................... typedef volatile int32u tickType; 
....................  
.................... //Event Structure 
.................... typedef volatile struct 
.................... { 
....................     EV_TYPE evType; 
....................     void *evDataPtr; 
.................... } EV_STRUCT; 
....................  
.................... //Event Queue Structure 
.................... typedef volatile struct 
.................... { 
....................     int8u evQLength; 
....................     int8u evQCount; 
....................     int8u evQPut; 
....................     int8u evQGet; 
....................     EV_STRUCT *evQArray; 
.................... } EVQ_STRUCT; 
....................  
.................... //Event Queue function error codes 
.................... typedef enum 
.................... { 
....................     EVQ_OK, 
....................     EVQ_FULL, 
....................     EVQ_EMPTY 
.................... } Q_ERR; 
....................  
.................... //Structure of pointer for memm queue array 
.................... typedef volatile struct voidPtrStrict 
.................... { 
....................     void *blockPtr; 
.................... } PTR_STRUCT; 
....................  
.................... //Structure type for Mem Control Block 
.................... typedef volatile struct memControlStruct 
.................... { 
....................     void *memPtr; 
....................     int16u qArrayLength; 
....................     int16u count; 
....................     int16u put; 
....................     int16u get; 
....................     PTR_STRUCT *qArrayPtr; // Pointer to array of pointer to void 
.................... } MCB_STRUCT; 
....................  
.................... //Structure type for queue of pointer 
.................... typedef volatile struct qPtrXStruct 
.................... { 
....................     int16u arrayLength; 
....................     int16u count; 
....................     int16u put; 
....................     int16u get; 
....................     PTR_STRUCT *arrayPtr; // Pointer to array of pointer to void 
.................... } QPTRX_STRUCT; 
....................  
.................... //Structure type for queue of int8u 
.................... typedef volatile struct q8UStruct 
.................... { 
....................     int16u arrayLength; 
....................     int16u count; 
....................     int16u put; 
....................     int16u get; 
....................     int8u *arrayPtr; // Pointer to array of int8u 
.................... } Q8UX_STRUCT; 
....................  
.................... //STimer struct 
.................... typedef volatile struct 
.................... { 
....................     int8u tmrEnb; //enable (ON) / disable (OFF) software timer 
....................     int8u tmrMode; //operating mode: SINGLE / REPEAT 
....................     tickType tmrInit; // Initial value of tick count 
....................     tickType tmrCount; //Down Counter value 
....................     EVQ_STRUCT *evQPtr; // Pointer to Event Queue 
....................     EV_STRUCT sTmrEvStruct; //software Timer Event Structure 
.................... } STMR_STRUCT; 
....................  
.................... //RX Frame State 
.................... typedef volatile enum 
.................... { 
....................     FRAME_WAIT, 
....................     FRAME_PROGRESS 
.................... } FRAME_STATE;  
....................  
.................... //Tx state 
.................... typedef volatile enum 
.................... { 
....................     TX1_BUSY, 
....................     TX1_READY 
.................... } TX1_STATUS; 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #ifndef EVENT_DRIVEN_CCS_C_SRC 
....................  
.................... extern volatile int16u EvQFullCount; 
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                          Library Functions                               // 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /*************************  Event Queue Functions  **************************/ 
.................... /****************************************************************************/ 
....................  
.................... void EvSructInit (EV_STRUCT *evStruct , EV_TYPE evType, void *evDataPtr ); 
....................  
.................... void EvQInit (EVQ_STRUCT *evQ, EV_STRUCT *evArray, int8u qL ); 
....................  
.................... void EvQPut (EVQ_STRUCT *evQ, EV_STRUCT evSource, Q_ERR *errPtr); 
....................  
.................... void EvQGet (EVQ_STRUCT *evQ, EV_STRUCT *evDest, Q_ERR *errPtr); 
....................  
.................... int16u EvQCount (EVQ_STRUCT *evQ); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /****************************  Memory Functions  ****************************/ 
.................... /****************************************************************************/ 
....................  
.................... void MemStructArrayInit (void *memArrayPtr, int16u blockByteSize, int16u nBlock, 
....................                          PTR_STRUCT *memQArrayPtr, MCB_STRUCT *memQcbPtr); 
....................  
.................... void MemPtrPut (MCB_STRUCT *memQcbPtr, void *memBlockPtr, int8u *errPtr); 
....................  
.................... void MemPtrGet (MCB_STRUCT *memQcbPtr, PTR_STRUCT *destStructPtr, int8u *errPtr); 
....................  
.................... int16u MemQReadyCount (MCB_STRUCT *memQcbPtr); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /***************************** QPTRX Functions  *****************************/ 
.................... /****************************************************************************/ 
....................  
.................... void QPtrXInit (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *buffPtr, int16u qL); 
....................  
.................... void QPtrXPut (QPTRX_STRUCT *qStructPtr, PTR_STRUCT ptrStruct, int8u *errPtr); 
....................  
.................... void QPtrXGet (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *destPtr, int8u *errPtr); 
....................  
.................... int16u QPtrXCount (QPTRX_STRUCT *qStructPtr); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /***************************** Q8UX Functions *******************************/ 
.................... /****************************************************************************/ 
....................  
.................... void Q8UXInit (Q8UX_STRUCT *qStructPtr, int8u *buffPtr, int16u qL); 
....................  
.................... void Q8UXPut (Q8UX_STRUCT *qStructPtr, int8u dataSource, int8u *errPtr); 
....................  
.................... void Q8UXGet (Q8UX_STRUCT *qStructPtr, int8u *destPtr, int8u *errPtr); 
....................  
.................... int16u Q8UXCount (Q8UX_STRUCT *qStructPtr); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /************************ Software Timer Functions  *************************/ 
.................... /****************************************************************************/ 
....................  
.................... void SoftwareTimer (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr); 
....................  
.................... void STmrSystemDeInit (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr); 
....................  
.................... void STmrInit (STMR_STRUCT *sTmrPtr, int8u z, tickType, initValue, int8u mode, 
....................                EV_TYPE evType, void *evDataPtr, EVQ_STRUCT *evQPtr); 
....................  
.................... void STmrStart (STMR_STRUCT *sTmrPtr, int8u z); 
....................  
.................... void StmrPause (STMR_STRUCT *sTmrPtr, int8u z); 
....................  
.................... void STmrStop (STMR_STRUCT *sTmrPtr, int8u z); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                           CPU Dependent Functions   
.................... /****************************************************************************/ 
....................  
.................... void DisableIntr (void); 
....................  
.................... void EnableIntr (void); 
....................  
.................... void CpuIdle (void); 
....................  
....................  
.................... /****************************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #define START_DUTY 0 
.................... #define STOP 0 
.................... #define CW 1  
.................... #define CCW 2 
.................... #define MOTOR_L 1 
.................... #define MOTOR_R 2 
.................... #define RED_X 0 
.................... #define RED_Y 0 
.................... #define GREEN_X 0 
.................... #define GREEN_Y 0 
.................... #define BLUE_X 0 
.................... #define BLUE_Y 0 
....................  
.................... #define RX1Q_LN 8 
.................... #define RX_CMND_FRM_LN 25 
.................... #define START_CHR   '[' 
.................... #define END_CHR     ']' 
.................... #define CONDITION_S '(' 
.................... #define CONDITION_E ')' 
.................... #define CONDITION_M ',' 
.................... //UART Queue 
.................... #define TX1Q_LN 128 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                      PROTOTYPES OF LOCAL FUNCTIONS                     **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... static void HardwareInit (void); 
.................... static void GlobalVarInit (void); 
.................... static void DynamicMemInit (void); 
.................... static void UARTQueueInit (void); 
.................... static int8u SendTx1 (int8u *strPtr); 
....................  
.................... //My Function 
.................... static void create_position_array(void); 
.................... static int8u ConvertStr2Int (int8u num); 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED VARIABLES                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                            GLOBAL VARIABLES                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... float Kp_x = 0.0f,Kp_y = 0.0f; 
.................... float Ki_x = 0.0f,Ki_y = 0.0f; 
.................... float Kd_x = 0.0f,Kd_y = 0.0f; 
.................... int16s e_x = 0,e_y = 0; 
.................... float int_e_x = 0,int_e_y = 0; 
.................... float u_x = 0,u_y = 0; 
.................... float control_x = 0,control_y = 0; 
.................... float p_e_x = 0,p_e_y = 0; 
.................... float tor = 2; 
.................... static int16u duty1; 
.................... int32s count_pulseX = 0;  
.................... int32s count_pulseY = 0;  
.................... float thetaX = 0; 
.................... float thetaY = 0; 
.................... int DistanceX = 0; 
.................... int DistanceY = 0; 
.................... int16u target_posX = 0; 
.................... int16u target_posY = 0; 
.................... int h; 
.................... static float current_posX = 0; 
.................... static float current_posY = 0; 
.................... int16u ReadPortB,B0,B1,B2,B3; 
.................... float radius = 12.20; //old radius = 11.92 
....................  
.................... int home_state = 1; 
.................... char move_state; 
.................... int x,y; 
.................... int send_end = 0; 
....................  
.................... static volatile Q8UX_STRUCT Tx1QCB; 
.................... static volatile int8u Tx1QArray[TX1Q_LN]; 
.................... static volatile int8u *Tx1BuffPtr; 
.................... static volatile int16u TxBuffIdx; 
.................... static volatile TX1_STATUS Tx1Flag; 
.................... static volatile int16u Tx1FrameIn, Tx1FrameOut, Rx1FrameCount, RxCount, 
....................                         Tx1QFullCount, Rx1QFullCount; 
....................  
.................... static volatile int8u *RxBuffPtr; 
.................... static volatile QPTRX_STRUCT Rx1QCB; 
.................... static volatile PTR_STRUCT Rx1BuffPtrArray[RX1Q_LN]; 
.................... static volatile PTR_STRUCT DestPtrStruct; 
....................  
.................... static volatile int16u MemFail, MemCount; 
....................  
.................... static int position_x[50]; 
.................... static int position_y[50]; 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED FUNCTIONS                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... void drive_motor(int axis,int direction,int speed){ 
.................... /*************************** 
.................... 	MotorLeft(CW) >> IN1  H 
.................... 				  >> IN2  L 
.................... 	MotorRight(CW) >> IN3  H 
.................... 	               >> IN4  L 
.................... 	Y_PLUS = Left(CW) + Right(CCW) 
.................... 	X_PLUS = Left(CW) + Right(CW) 
.................... ****************************/ 
.................... 	 
.................... 	if(speed == 0 || direction == STOP){		 
*
11FC:  CP0     B56
11FE:  BRA     Z,1204
1200:  CP0     B54
1202:  BRA     NZ,1224
.................... 		if(axis == MOTOR_L){ 
1204:  MOV     B52,W4
1206:  CP      W4,#1
1208:  BRA     NZ,1210
.................... 			output_low(IN3); 
120A:  BCLR.B  2C4.2
.................... 			output_low(IN4); 
120C:  BCLR.B  2C4.4
.................... 		} 
120E:  BRA     121A
.................... 		else if(axis == MOTOR_R){ 
1210:  MOV     B52,W4
1212:  CP      W4,#2
1214:  BRA     NZ,121A
.................... 			output_low(IN1); 
1216:  BCLR.B  2C4.0
.................... 			output_low(IN2); 
1218:  BCLR.B  2C4.1
.................... 		}	 
.................... 		set_pwm_duty(1, 400); 
121A:  MOV     #190,W4
121C:  MOV     W4,180
.................... 		set_pwm_duty(2, 400); 			 
121E:  MOV     #190,W4
1220:  MOV     W4,186
.................... 	} 
1222:  BRA     127E
.................... 	else if(axis == MOTOR_L){ 
1224:  MOV     B52,W4
1226:  CP      W4,#1
1228:  BRA     NZ,1252
.................... 		if(direction == CW){ 
122A:  MOV     B54,W4
122C:  CP      W4,#1
122E:  BRA     NZ,123E
.................... 			output_high(IN3); 
1230:  BSET.B  2C4.2
.................... 			output_low(IN4); 
1232:  BCLR.B  2C4.4
.................... 			set_pwm_duty(1, speed); 
1234:  PUSH    B56
1236:  POP     180
.................... 			set_pwm_duty(2, speed); 
1238:  PUSH    B56
123A:  POP     186
.................... 		} 
123C:  BRA     1250
.................... 		else if(direction == CCW){ 
123E:  MOV     B54,W4
1240:  CP      W4,#2
1242:  BRA     NZ,1250
.................... 			output_low(IN3); 
1244:  BCLR.B  2C4.2
.................... 			output_high(IN4); 
1246:  BSET.B  2C4.4
.................... 			set_pwm_duty(1, speed); 
1248:  PUSH    B56
124A:  POP     180
.................... 			set_pwm_duty(2, speed); 
124C:  PUSH    B56
124E:  POP     186
.................... 		} 
.................... 	} 
1250:  BRA     127E
.................... 	else if(axis == MOTOR_R){ 
1252:  MOV     B52,W4
1254:  CP      W4,#2
1256:  BRA     NZ,127E
.................... 		if(direction == CW){ 
1258:  MOV     B54,W4
125A:  CP      W4,#1
125C:  BRA     NZ,126C
.................... 			output_high(IN1);     
125E:  BSET.B  2C4.0
.................... 			output_low(IN2); 
1260:  BCLR.B  2C4.1
.................... 			set_pwm_duty(1, speed); 
1262:  PUSH    B56
1264:  POP     180
.................... 			set_pwm_duty(2, speed); 
1266:  PUSH    B56
1268:  POP     186
.................... 		} 
126A:  BRA     127E
.................... 		else if(direction == CCW){ 
126C:  MOV     B54,W4
126E:  CP      W4,#2
1270:  BRA     NZ,127E
.................... 			output_low(IN1);     
1272:  BCLR.B  2C4.0
.................... 			output_high(IN2); 
1274:  BSET.B  2C4.1
.................... 			set_pwm_duty(1, speed); 
1276:  PUSH    B56
1278:  POP     180
.................... 			set_pwm_duty(2, speed); 
127A:  PUSH    B56
127C:  POP     186
.................... 		} 
.................... 	} 
127E:  RETURN  
.................... 	 
.................... } 
....................  
.................... void control_position(int axis, float target, float currentPosition) { 
*
1D1E:  MOV     W5,[W15++]
1D20:  MOV     W6,[W15++]
.................... 	if(axis == MOTOR_L){ 
1D22:  MOV     B0C,W4
1D24:  CP      W4,#1
1D26:  BRA     NZ,1EDE
.................... 		float targetX = target; 
.................... 		float currentX = currentPosition; 
1D28:  PUSH    B0E
1D2A:  POP     B16
1D2C:  PUSH    B10
1D2E:  POP     B18
1D30:  PUSH    B12
1D32:  POP     B1A
1D34:  PUSH    B14
1D36:  POP     B1C
.................... 		Kp_x = 20;         //old value = 20 
1D38:  CLR     8BA
1D3A:  MOV     #41A0,W4
1D3C:  MOV     W4,8BC
.................... 		Ki_x = 0.00001;     //old value = 0.00001 
1D3E:  MOV     #C5AC,W4
1D40:  MOV     W4,8C2
1D42:  MOV     #3727,W4
1D44:  MOV     W4,8C4
.................... 		Kd_x = 8;       //old value = 8 
1D46:  CLR     8CA
1D48:  MOV     #4100,W4
1D4A:  MOV     W4,8CC
....................  
.................... 		e_x = targetX - currentX; 
1D4C:  BSET.B  43.0
1D4E:  MOV     B16,W0
1D50:  MOV     B18,W1
1D52:  MOV     B1A,W2
1D54:  MOV     B1C,W3
1D56:  CALL    1A96
1D5A:  CALL    1C40
1D5E:  MOV     W0,8D2
.................... 		int_e_x = int_e_x + e_x; 
1D60:  MOV     8D2,W0
1D62:  CALL    1C6C
1D66:  BCLR.B  43.0
1D68:  MOV     W0,W2
1D6A:  MOV     W1,W3
1D6C:  MOV     8D6,W0
1D6E:  MOV     8D8,W1
1D70:  CALL    1A96
1D74:  MOV     W0,8D6
1D76:  MOV     W1,8D8
.................... 		u_x = Kp_x*e_x + Ki_x*int_e_x + Kd_x*(e_x-p_e_x); 
1D78:  MOV     8D2,W0
1D7A:  CALL    1C6C
1D7E:  MOV     W0,W2
1D80:  MOV     W1,W3
1D82:  MOV     8BA,W0
1D84:  MOV     8BC,W1
1D86:  CALL    176E
1D8A:  MOV     W0,W5
1D8C:  MOV     W1,W6
1D8E:  MOV     8C2,W0
1D90:  MOV     8C4,W1
1D92:  MOV     8D6,W2
1D94:  MOV     8D8,W3
1D96:  CALL    176E
1D9A:  BCLR.B  43.0
1D9C:  MOV     W0,W2
1D9E:  MOV     W1,W3
1DA0:  MOV     W5,W0
1DA2:  MOV     W6,W1
1DA4:  CALL    1A96
1DA8:  MOV     W0,W5
1DAA:  MOV     W1,W6
1DAC:  MOV     8D2,W0
1DAE:  CALL    1C6C
1DB2:  BSET.B  43.0
1DB4:  MOV     8EE,W2
1DB6:  MOV     8F0,W3
1DB8:  CALL    1A96
1DBC:  MOV     W0,W2
1DBE:  MOV     W1,W3
1DC0:  MOV     8CA,W0
1DC2:  MOV     8CC,W1
1DC4:  CALL    176E
1DC8:  BCLR.B  43.0
1DCA:  MOV     W0,W2
1DCC:  MOV     W1,W3
1DCE:  MOV     W5,W0
1DD0:  MOV     W6,W1
1DD2:  CALL    1A96
1DD6:  MOV     W0,8DE
1DD8:  MOV     W1,8E0
.................... 		/*x = currentX; 
.................... 		printf("\r\nX = %d||Y = %d",x,y);*/ 
.................... 		p_e_x = e_x;   
1DDA:  MOV     8D2,W0
1DDC:  CALL    1C6C
1DE0:  MOV     W0,8EE
1DE2:  MOV     W1,8F0
.................... 		 
.................... 		if (abs(e_x)>tor){ 
1DE4:  MOV     8D2,W0
1DE6:  BTSS    W0.F
1DE8:  BRA     1DF0
1DEA:  MOV     #0,W4
1DEC:  MOV     8D2,W3
1DEE:  SUB     W4,W3,W0
1DF0:  MOV     W0,W5
1DF2:  MOV     W5,W0
1DF4:  CALL    1C6C
1DF8:  MOV     W0,W2
1DFA:  MOV     W1,W3
1DFC:  MOV     8F6,W0
1DFE:  MOV     8F8,W1
1E00:  CALL    1CB6
1E04:  BRA     NC,1EB0
.................... 			if(abs(u_x) > 255){ 
1E06:  MOV     8DE,W0
1E08:  MOV     8E0,W1
1E0A:  BCLR    W1.F
1E0C:  MOV     W0,W5
1E0E:  MOV     W1,W6
1E10:  MOV     #0,W0
1E12:  MOV     #437F,W1
1E14:  MOV     W5,W2
1E16:  MOV     W6,W3
1E18:  CALL    1CB6
1E1C:  BRA     NC,1E26
.................... 				control_x = 255;	 
1E1E:  CLR     8E6
1E20:  MOV     #437F,W4
1E22:  MOV     W4,8E8
.................... 			} 
1E24:  BRA     1E6E
.................... 			else if(abs(u_x)<50){ 
1E26:  MOV     8DE,W0
1E28:  MOV     8E0,W1
1E2A:  BCLR    W1.F
1E2C:  MOV     W0,W5
1E2E:  MOV     W1,W6
1E30:  MOV     W5,W0
1E32:  MOV     W6,W1
1E34:  MOV     #0,W2
1E36:  MOV     #4248,W3
1E38:  CALL    1CB6
1E3C:  BRA     NC,1E44
.................... 				control_x = abs((50/255)*400); 
1E3E:  CLR     8E6
1E40:  CLR     8E8
.................... 			}else{ 
1E42:  BRA     1E6E
.................... 				control_x = abs((u_x/255)*400); 
1E44:  MOV     8DE,W0
1E46:  MOV     8E0,W1
1E48:  MOV     #0,W2
1E4A:  MOV     #437F,W3
1E4C:  CALL    1832
1E50:  MOV     W0,W5
1E52:  MOV     W1,W6
1E54:  MOV     W5,W0
1E56:  MOV     W6,W1
1E58:  MOV     #0,W2
1E5A:  MOV     #43C8,W3
1E5C:  CALL    176E
1E60:  MOV     W0,W5
1E62:  MOV     W1,W6
1E64:  MOV     W5,W0
1E66:  MOV     W6,W1
1E68:  BCLR    W1.F
1E6A:  MOV     W0,8E6
1E6C:  MOV     W1,8E8
.................... 			} 
.................... 			 
.................... 			if (u_x>0){ 
1E6E:  MOV     #0,W0
1E70:  MOV     #0,W1
1E72:  MOV     8DE,W2
1E74:  MOV     8E0,W3
1E76:  CALL    1CB6
1E7A:  BRA     NC,1E96
.................... 				drive_motor(axis,CW,control_x); 
1E7C:  MOV     8E6,W0
1E7E:  MOV     8E8,W1
1E80:  CALL    1C40
1E84:  MOV     W0,W5
1E86:  PUSH    B0C
1E88:  POP     B52
1E8A:  MOV     #1,W4
1E8C:  MOV     W4,B54
1E8E:  MOV     W5,B56
1E90:  CALL    11FC
.................... 			} 
1E94:  BRA     1EAE
.................... 			else{ 
.................... 				drive_motor(axis,CCW,control_x); 
1E96:  MOV     8E6,W0
1E98:  MOV     8E8,W1
1E9A:  CALL    1C40
1E9E:  MOV     W0,W5
1EA0:  PUSH    B0C
1EA2:  POP     B52
1EA4:  MOV     #2,W4
1EA6:  MOV     W4,B54
1EA8:  MOV     W5,B56
1EAA:  CALL    11FC
.................... 			} 
.................... 		}else{ 
1EAE:  BRA     1EDC
.................... 				drive_motor(MOTOR_L,STOP,0); 
1EB0:  MOV     #1,W4
1EB2:  MOV     W4,B52
1EB4:  CLR     B54
1EB6:  CLR     B56
1EB8:  CALL    11FC
.................... 				if(send_end == 0){ 
1EBC:  CP0     934
1EBE:  BRA     NZ,1EDC
.................... 					printf("[e]"); 
1EC0:  BTSC.B  223.1
1EC2:  BRA     1EC0
1EC4:  MOV     #5B,W4
1EC6:  MOV     W4,224
1EC8:  BTSC.B  223.1
1ECA:  BRA     1EC8
1ECC:  MOV     #65,W4
1ECE:  MOV     W4,224
1ED0:  BTSC.B  223.1
1ED2:  BRA     1ED0
1ED4:  MOV     #5D,W4
1ED6:  MOV     W4,224
.................... 					send_end = 1; 
1ED8:  MOV     #1,W4
1EDA:  MOV     W4,934
.................... 				} 
.................... 		} 
.................... 	} 
1EDC:  BRA     209A
.................... 	else if(axis == MOTOR_R){ 
1EDE:  MOV     B0C,W4
1EE0:  CP      W4,#2
1EE2:  BRA     NZ,209A
.................... 		float targetY = target; 
.................... 		float currentY = currentPosition; 
1EE4:  PUSH    B0E
1EE6:  POP     B1E
1EE8:  PUSH    B10
1EEA:  POP     B20
1EEC:  PUSH    B12
1EEE:  POP     B22
1EF0:  PUSH    B14
1EF2:  POP     B24
.................... 		Kp_y = 20;          //old value = 29.5 
1EF4:  CLR     8BE
1EF6:  MOV     #41A0,W4
1EF8:  MOV     W4,8C0
.................... 		Ki_y = 0.000001;  //old value = 0.0001 
1EFA:  MOV     #37BD,W4
1EFC:  MOV     W4,8C6
1EFE:  MOV     #3586,W4
1F00:  MOV     W4,8C8
.................... 		Kd_y = 0.0001;			 //old value = 13 
1F02:  MOV     #B717,W4
1F04:  MOV     W4,8CE
1F06:  MOV     #38D1,W4
1F08:  MOV     W4,8D0
....................  
.................... 		e_y = targetY - currentY; 
1F0A:  BSET.B  43.0
1F0C:  MOV     B1E,W0
1F0E:  MOV     B20,W1
1F10:  MOV     B22,W2
1F12:  MOV     B24,W3
1F14:  CALL    1A96
1F18:  CALL    1C40
1F1C:  MOV     W0,8D4
.................... 		int_e_y = int_e_y + e_y; 
1F1E:  MOV     8D4,W0
1F20:  CALL    1C6C
1F24:  BCLR.B  43.0
1F26:  MOV     W0,W2
1F28:  MOV     W1,W3
1F2A:  MOV     8DA,W0
1F2C:  MOV     8DC,W1
1F2E:  CALL    1A96
1F32:  MOV     W0,8DA
1F34:  MOV     W1,8DC
.................... 		u_y = Kp_y*e_y + Ki_y*int_e_y + Kd_y*(e_y-p_e_y); 
1F36:  MOV     8D4,W0
1F38:  CALL    1C6C
1F3C:  MOV     W0,W2
1F3E:  MOV     W1,W3
1F40:  MOV     8BE,W0
1F42:  MOV     8C0,W1
1F44:  CALL    176E
1F48:  MOV     W0,W5
1F4A:  MOV     W1,W6
1F4C:  MOV     8C6,W0
1F4E:  MOV     8C8,W1
1F50:  MOV     8DA,W2
1F52:  MOV     8DC,W3
1F54:  CALL    176E
1F58:  BCLR.B  43.0
1F5A:  MOV     W0,W2
1F5C:  MOV     W1,W3
1F5E:  MOV     W5,W0
1F60:  MOV     W6,W1
1F62:  CALL    1A96
1F66:  MOV     W0,W5
1F68:  MOV     W1,W6
1F6A:  MOV     8D4,W0
1F6C:  CALL    1C6C
1F70:  BSET.B  43.0
1F72:  MOV     8F2,W2
1F74:  MOV     8F4,W3
1F76:  CALL    1A96
1F7A:  MOV     W0,W2
1F7C:  MOV     W1,W3
1F7E:  MOV     8CE,W0
1F80:  MOV     8D0,W1
1F82:  CALL    176E
1F86:  BCLR.B  43.0
1F88:  MOV     W0,W2
1F8A:  MOV     W1,W3
1F8C:  MOV     W5,W0
1F8E:  MOV     W6,W1
1F90:  CALL    1A96
1F94:  MOV     W0,8E2
1F96:  MOV     W1,8E4
.................... 		/*y = currentY; 
.................... 		printf("\r\nX = %d||Y = %d",x,y);*/ 
.................... 		p_e_y = e_y;   
1F98:  MOV     8D4,W0
1F9A:  CALL    1C6C
1F9E:  MOV     W0,8F2
1FA0:  MOV     W1,8F4
.................... 		 
.................... 		if (abs(e_y)>tor){ 
1FA2:  MOV     8D4,W0
1FA4:  BTSS    W0.F
1FA6:  BRA     1FAE
1FA8:  MOV     #0,W4
1FAA:  MOV     8D4,W3
1FAC:  SUB     W4,W3,W0
1FAE:  MOV     W0,W5
1FB0:  MOV     W5,W0
1FB2:  CALL    1C6C
1FB6:  MOV     W0,W2
1FB8:  MOV     W1,W3
1FBA:  MOV     8F6,W0
1FBC:  MOV     8F8,W1
1FBE:  CALL    1CB6
1FC2:  BRA     NC,206E
.................... 			if(abs(u_y) > 255){ 
1FC4:  MOV     8E2,W0
1FC6:  MOV     8E4,W1
1FC8:  BCLR    W1.F
1FCA:  MOV     W0,W5
1FCC:  MOV     W1,W6
1FCE:  MOV     #0,W0
1FD0:  MOV     #437F,W1
1FD2:  MOV     W5,W2
1FD4:  MOV     W6,W3
1FD6:  CALL    1CB6
1FDA:  BRA     NC,1FE4
.................... 				control_y = 255; 
1FDC:  CLR     8EA
1FDE:  MOV     #437F,W4
1FE0:  MOV     W4,8EC
.................... 			} 
1FE2:  BRA     202C
.................... 			else if(abs(u_y) < 50){ 
1FE4:  MOV     8E2,W0
1FE6:  MOV     8E4,W1
1FE8:  BCLR    W1.F
1FEA:  MOV     W0,W5
1FEC:  MOV     W1,W6
1FEE:  MOV     W5,W0
1FF0:  MOV     W6,W1
1FF2:  MOV     #0,W2
1FF4:  MOV     #4248,W3
1FF6:  CALL    1CB6
1FFA:  BRA     NC,2002
.................... 				control_y = abs((50/255)*400); 
1FFC:  CLR     8EA
1FFE:  CLR     8EC
.................... 			}else{ 
2000:  BRA     202C
.................... 				control_y = abs((u_y/255)*400); 
2002:  MOV     8E2,W0
2004:  MOV     8E4,W1
2006:  MOV     #0,W2
2008:  MOV     #437F,W3
200A:  CALL    1832
200E:  MOV     W0,W5
2010:  MOV     W1,W6
2012:  MOV     W5,W0
2014:  MOV     W6,W1
2016:  MOV     #0,W2
2018:  MOV     #43C8,W3
201A:  CALL    176E
201E:  MOV     W0,W5
2020:  MOV     W1,W6
2022:  MOV     W5,W0
2024:  MOV     W6,W1
2026:  BCLR    W1.F
2028:  MOV     W0,8EA
202A:  MOV     W1,8EC
.................... 			} 
.................... 			if (u_y>0){ 
202C:  MOV     #0,W0
202E:  MOV     #0,W1
2030:  MOV     8E2,W2
2032:  MOV     8E4,W3
2034:  CALL    1CB6
2038:  BRA     NC,2054
.................... 				drive_motor(axis,CW,control_y); 
203A:  MOV     8EA,W0
203C:  MOV     8EC,W1
203E:  CALL    1C40
2042:  MOV     W0,W5
2044:  PUSH    B0C
2046:  POP     B52
2048:  MOV     #1,W4
204A:  MOV     W4,B54
204C:  MOV     W5,B56
204E:  CALL    11FC
.................... 			} 
2052:  BRA     206C
.................... 			else{ 
.................... 				drive_motor(axis,CCW,control_y); 
2054:  MOV     8EA,W0
2056:  MOV     8EC,W1
2058:  CALL    1C40
205C:  MOV     W0,W5
205E:  PUSH    B0C
2060:  POP     B52
2062:  MOV     #2,W4
2064:  MOV     W4,B54
2066:  MOV     W5,B56
2068:  CALL    11FC
.................... 			} 
.................... 			 
.................... 		}else{ 
206C:  BRA     209A
.................... 			drive_motor(MOTOR_R,STOP,0); 
206E:  MOV     #2,W4
2070:  MOV     W4,B52
2072:  CLR     B54
2074:  CLR     B56
2076:  CALL    11FC
.................... 			if(send_end == 0){ 
207A:  CP0     934
207C:  BRA     NZ,209A
.................... 				printf("[e]"); 
207E:  BTSC.B  223.1
2080:  BRA     207E
2082:  MOV     #5B,W4
2084:  MOV     W4,224
2086:  BTSC.B  223.1
2088:  BRA     2086
208A:  MOV     #65,W4
208C:  MOV     W4,224
208E:  BTSC.B  223.1
2090:  BRA     208E
2092:  MOV     #5D,W4
2094:  MOV     W4,224
.................... 				send_end = 1; 
2096:  MOV     #1,W4
2098:  MOV     W4,934
.................... 			} 
.................... 		} 
.................... 		 
.................... 	} 
209A:  MOV     [--W15],W6
209C:  MOV     [--W15],W5
209E:  RETURN  
.................... 	 
.................... } 
.................... void Encoder(void){ 
*
18FC:  MOV     W5,[W15++]
18FE:  MOV     W6,[W15++]
1900:  MOV     W7,[W15++]
1902:  MOV     W8,[W15++]
.................... 	thetaX = (count_pulseX*7.5)/64; 
1904:  MOV     8FC,W0
1906:  MOV     8FE,W1
1908:  CLR     W3
190A:  BTSC    W1.F
190C:  SETM    W3
190E:  MOV     W3,W2
1910:  CALL    14AE
1914:  MOV     #0,W4
1916:  MOV     #0,W5
1918:  MOV     #0,W6
191A:  MOV     #401E,W7
191C:  CALL    1512
1920:  MOV     W0,W5
1922:  MOV     W1,W6
1924:  MOV     W2,W7
1926:  MOV     W3,W8
1928:  MOV     W5,[W15++]
192A:  MOV     W6,[W15++]
192C:  MOV     W7,[W15++]
192E:  MOV     W5,W0
1930:  MOV     W6,W1
1932:  MOV     W7,W2
1934:  MOV     W8,W3
1936:  MOV     #0,W4
1938:  MOV     #0,W5
193A:  MOV     #0,W6
193C:  MOV     #4050,W7
193E:  CALL    1622
1942:  MOV     [--W15],W7
1944:  MOV     [--W15],W6
1946:  MOV     [--W15],W5
1948:  CALL    172A
194C:  MOV     W1,904
194E:  MOV     W2,906
.................... 	thetaY = (count_pulseY*7.5)/64; 
1950:  MOV     900,W0
1952:  MOV     902,W1
1954:  CLR     W3
1956:  BTSC    W1.F
1958:  SETM    W3
195A:  MOV     W3,W2
195C:  CALL    14AE
1960:  MOV     #0,W4
1962:  MOV     #0,W5
1964:  MOV     #0,W6
1966:  MOV     #401E,W7
1968:  CALL    1512
196C:  MOV     W0,W5
196E:  MOV     W1,W6
1970:  MOV     W2,W7
1972:  MOV     W3,W8
1974:  MOV     W5,[W15++]
1976:  MOV     W6,[W15++]
1978:  MOV     W7,[W15++]
197A:  MOV     W5,W0
197C:  MOV     W6,W1
197E:  MOV     W7,W2
1980:  MOV     W8,W3
1982:  MOV     #0,W4
1984:  MOV     #0,W5
1986:  MOV     #0,W6
1988:  MOV     #4050,W7
198A:  CALL    1622
198E:  MOV     [--W15],W7
1990:  MOV     [--W15],W6
1992:  MOV     [--W15],W5
1994:  CALL    172A
1998:  MOV     W1,908
199A:  MOV     W2,90A
.................... 	current_posX = (thetaX*(22/7)*radius)/180; 
199C:  MOV     904,W0
199E:  MOV     906,W1
19A0:  MOV     #0,W2
19A2:  MOV     #4040,W3
19A4:  CALL    176E
19A8:  MOV     W0,W5
19AA:  MOV     W1,W6
19AC:  MOV     W5,W0
19AE:  MOV     W6,W1
19B0:  MOV     928,W2
19B2:  MOV     92A,W3
19B4:  CALL    176E
19B8:  MOV     W0,W5
19BA:  MOV     W1,W6
19BC:  MOV     W5,W0
19BE:  MOV     W6,W1
19C0:  MOV     #0,W2
19C2:  MOV     #4334,W3
19C4:  CALL    1832
19C8:  MOV     W0,916
19CA:  MOV     W1,918
.................... 	current_posY = (thetaY*(22/7)*radius)/180; 
19CC:  MOV     908,W0
19CE:  MOV     90A,W1
19D0:  MOV     #0,W2
19D2:  MOV     #4040,W3
19D4:  CALL    176E
19D8:  MOV     W0,W5
19DA:  MOV     W1,W6
19DC:  MOV     W5,W0
19DE:  MOV     W6,W1
19E0:  MOV     928,W2
19E2:  MOV     92A,W3
19E4:  CALL    176E
19E8:  MOV     W0,W5
19EA:  MOV     W1,W6
19EC:  MOV     W5,W0
19EE:  MOV     W6,W1
19F0:  MOV     #0,W2
19F2:  MOV     #4334,W3
19F4:  CALL    1832
19F8:  MOV     W0,91A
19FA:  MOV     W1,91C
19FC:  MOV     [--W15],W8
19FE:  MOV     [--W15],W7
1A00:  MOV     [--W15],W6
1A02:  MOV     [--W15],W5
1A04:  RETURN  
.................... } 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             LOCAL FUNCTIONS                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... int main (void) 
*
2760:  MOV     #2780,W15
2762:  MOV     #27FF,W0
2764:  MOV     W0,20
2766:  NOP     
2768:  MOV     #4444,W0
276A:  MOV     W0,A4
276C:  MOV     #4444,W0
276E:  MOV     W0,A8
2770:  MOV     #4444,W0
2772:  MOV     W0,B0
2774:  BSET.B  81.7
2776:  MOV     #46,W0
2778:  MOV.B   W0L,742
277A:  MOV     #57,W0
277C:  MOV.B   W0L,742
277E:  BCLR.B  742.6
2780:  MOV     #53F,W0
2782:  MOV     W0,680
2784:  MOV     #3F04,W0
2786:  MOV     W0,682
2788:  MOV     #100,W0
278A:  MOV     W0,68E
278C:  MOV     #302,W0
278E:  MOV     W0,690
2790:  MOV     #3F0C,W0
2792:  MOV     W0,6A4
2794:  MOV     #1312,W0
2796:  MOV     W0,6C6
2798:  MOV     #300,W0
279A:  MOV     W0,6CC
279C:  MOV     #46,W0
279E:  MOV.B   W0L,742
27A0:  MOV     #57,W0
27A2:  MOV.B   W0L,742
27A4:  BSET.B  742.6
27A6:  CLR     744
27A8:  MOV     #8000,W4
27AA:  MOV     W4,220
27AC:  MOV     #400,W4
27AE:  MOV     W4,222
27B0:  BSET.B  220.3
27B2:  MOV     #22,W4
27B4:  MOV     W4,228
27B6:  BRA     287E
27B8:  DATA    80,02,03
27BA:  DATA    2C,FF,FF
27BC:  DATA    80,02,07
27BE:  DATA    44,00,00
27C0:  DATA    80,02,07
27C2:  DATA    44,00,00
27C4:  DATA    80,02,08
27C6:  DATA    00,00,00
27C8:  DATA    80,02,08
27CA:  DATA    00,00,00
27CC:  DATA    80,02,08
27CE:  DATA    00,00,00
27D0:  DATA    C0,08,08
27D2:  DATA    08,00,00
27D4:  DATA    4B,F0,3F
27D6:  DATA    5C,0A,58
27D8:  DATA    F6,3B,8F
27DA:  DATA    00,C0,3C
27DC:  DATA    8B,28,AC
27DE:  DATA    3C,BE,F6
27E0:  DATA    3F,D2,D5
27E2:  DATA    44,16,8C
27E4:  DATA    15,D7,BF
27E6:  DATA    69,00,5A
27E8:  DATA    2E,1B,87
27EA:  DATA    99,3F,9A
27EC:  DATA    5F,AD,4B
27EE:  DATA    91,E4,01
27F0:  DATA    C0,5D,11
27F2:  DATA    2F,92,E4
27F4:  DATA    81,FB,3F
27F6:  DATA    38,DA,91
27F8:  DATA    80,9D,C5
27FA:  DATA    E0,BF,6F
27FC:  DATA    12,C0,B4
27FE:  DATA    C3,09,AB
2800:  DATA    3F,6B,C1
2802:  DATA    03,4E,C1
2804:  DATA    B5,45,BF
2806:  DATA    F7,40,05
2808:  DATA    FF,00,5A
280A:  DATA    EF,3F,F3
280C:  DATA    A3,E2,F7
280E:  DATA    D7,FF,01
2810:  DATA    40,C0,B4
2812:  DATA    FF,05,3C
2814:  DATA    58,FC,3F
2816:  DATA    3B,D3,C0
2818:  DATA    B5,BA,8C
281A:  DATA    E2,3F,39
281C:  DATA    D3,C7,3D
281E:  DATA    41,79,B2
2820:  DATA    3F,87,0D
2822:  DATA    3C,50,D0
2824:  DATA    AF,62,3F
2826:  DATA    30,4B,8D
2828:  DATA    A2,82,AA
282A:  DATA    04,40,09
282C:  DATA    A0,40,4A
282E:  DATA    05,76,03
2830:  DATA    40,EC,9E
2832:  DATA    37,88,A6
2834:  DATA    44,F0,3F
2836:  DATA    8F,12,8D
2838:  DATA    29,9A,5B
283A:  DATA    C7,3F,0E
283C:  DATA    E0,80,7C
283E:  DATA    A1,D8,86
2840:  DATA    3F,29,4B
2842:  DATA    FB,95,C2
2844:  DATA    37,1A,3F
2846:  DATA    40,3F,00
2848:  DATA    00,01,40
284A:  DATA    40,1A,00
284C:  DATA    C0,08,09
284E:  DATA    16,00,80
2850:  DATA    06,09,28
2852:  DATA    33,33,43
2854:  DATA    41,01,00
2856:  DATA    80,01,09
2858:  DATA    2F,00,80
285A:  DATA    01,09,2F
285C:  DATA    00,C1,88
285E:  DATA    09,34,00
2860:  DATA    00,00,00
2862:  INC     W2,W2
2864:  CP      W2,#1
2866:  BRA     NZ,2870
2868:  TBLRDL  [W1],W3
286A:  TBLRDH  [W1++],W4
286C:  MOV.B   6,W0L
286E:  RETURN  
2870:  CP      W2,#2
2872:  BRA     NZ,2878
2874:  MOV.B   7,W0L
2876:  RETURN  
2878:  MOV.B   8,W0L
287A:  CLR     W2
287C:  RETURN  
287E:  MOV     #0,W6
2880:  MOV     #0,W0
2882:  MOV     W0,32
2884:  MOV     #27B8,W0
2886:  MOV     W0,W1
2888:  CLR     W2
288A:  CALL    2862
288E:  MOV.B   W0L,B
2890:  CALL    2862
2894:  MOV.B   W0L,A
2896:  CP0     W5
2898:  BRA     Z,28CC
289A:  BTSS    W5.F
289C:  BRA     28AC
289E:  CALL    2862
28A2:  MOV.B   W0L,D
28A4:  CALL    2862
28A8:  MOV.B   W0L,C
28AA:  BCLR    W5.F
28AC:  BTSS    W5.E
28AE:  BRA     28C0
28B0:  BCLR    W5.E
28B2:  DEC     W5,W5
28B4:  CALL    2862
28B8:  MOV.B   W0L,W7L
28BA:  REPEAT  W5
28BC:  MOV.B   W7L,[W6++]
28BE:  BRA     288A
28C0:  CALL    2862
28C4:  MOV.B   W0L,[W6++]
28C6:  DEC     W5,W5
28C8:  BRA     NZ,28C0
28CA:  BRA     288A
28CC:  MOV     #B5A,W4
28CE:  MOV     W4,806
28D0:  MOV     #1C22,W4
28D2:  MOV     W4,B5A
28D4:  CLR     B5C
....................  {		 
.................... 	int8u errCode, sendTx1Count; 
....................  
....................     DisableIntr (); 
28D6:  CALL    2234
....................     HardwareInit (); 
28DA:  CALL    223E
....................     GlobalVarInit (); 
28DE:  CALL    22F6
....................     DynamicMemInit (); 
28E2:  CALL    230A
....................     UARTQueueInit (); 
28E6:  CALL    23B2
....................     EnableIntr (); 
28EA:  CALL    23D4
....................     for(;;){ 
....................         DisableIntr(); 
28EE:  CALL    2234
....................         QPtrXGet(&Rx1QCB, &DestPtrStruct, &errCode); 
28F2:  MOV     #9D2,W4
28F4:  MOV     W4,ABE
28F6:  MOV     #9EC,W4
28F8:  MOV     W4,AC0
28FA:  MOV     #ABC,W4
28FC:  MOV     W4,AC2
28FE:  CALL    23DC
....................         if (errCode == Q_OK) 
2902:  CP0.B   ABC
2904:  BRA     NZ,29A4
....................         { 
....................             create_position_array(); 
2906:  CALL    2568
.................... 			if(DestPtrStruct.blockPtr[0] == 'h'){  
290A:  MOV     #0,W0
290C:  ADD     9EC,W0
290E:  MOV.B   [W0],W4L
2910:  XOR.B   #68,W4L
2912:  BRA     NZ,2920
.................... 				/* HOME */ 
.................... 				disable_interrupts(INT_TIMER4); 
2914:  BCLR.B  97.3
.................... 				home_state = 1; 
2916:  MOV     #1,W4
2918:  MOV     W4,92C
.................... 				clear_interrupt(INT_TIMER1); 
291A:  BCLR.B  84.3
.................... 				enable_interrupts(INT_TIMER1); 
291C:  BSET.B  94.3
.................... 			} 
291E:  BRA     296E
.................... 			else if(DestPtrStruct.blockPtr[0] == 's'){ 
2920:  MOV     #0,W0
2922:  ADD     9EC,W0
2924:  MOV.B   [W0],W4L
2926:  XOR.B   #73,W4L
2928:  BRA     NZ,2934
.................... 				/*  Backward after pick pen */ 
.................... 				move_state = 's'; 
292A:  MOV.B   #73,W0L
292C:  MOV.B   W0L,92E
.................... 				clear_interrupt(INT_TIMER4); 
292E:  BCLR.B  87.3
.................... 				enable_interrupts(INT_TIMER4); 
2930:  BSET.B  97.3
.................... 			} 
2932:  BRA     296E
.................... 			else if(DestPtrStruct.blockPtr[0] == '1'){ 
2934:  MOV     #0,W0
2936:  ADD     9EC,W0
2938:  MOV.B   [W0],W4L
293A:  XOR.B   #31,W4L
293C:  BRA     NZ,2948
.................... 				/* Left Pen : Red & Orange*/ 
.................... 				move_state = '1'; 
293E:  MOV.B   #31,W0L
2940:  MOV.B   W0L,92E
.................... 				clear_interrupt(INT_TIMER4); 
2942:  BCLR.B  87.3
.................... 				enable_interrupts(INT_TIMER4); 
2944:  BSET.B  97.3
.................... 			} 
2946:  BRA     296E
.................... 			else if(DestPtrStruct.blockPtr[0] == '2'){ 
2948:  MOV     #0,W0
294A:  ADD     9EC,W0
294C:  MOV.B   [W0],W4L
294E:  XOR.B   #32,W4L
2950:  BRA     NZ,295C
.................... 				/* Middle Pen : Green*/ 
.................... 				move_state = '2'; 
2952:  MOV.B   #32,W0L
2954:  MOV.B   W0L,92E
.................... 				clear_interrupt(INT_TIMER4); 
2956:  BCLR.B  87.3
.................... 				enable_interrupts(INT_TIMER4); 
2958:  BSET.B  97.3
.................... 			} 
295A:  BRA     296E
.................... 			else if(DestPtrStruct.blockPtr[0] == '3'){ 
295C:  MOV     #0,W0
295E:  ADD     9EC,W0
2960:  MOV.B   [W0],W4L
2962:  XOR.B   #33,W4L
2964:  BRA     NZ,296E
.................... 				/* Right Pen : Blue & Black*/ 
.................... 				move_state = '3';	 
2966:  MOV.B   #33,W0L
2968:  MOV.B   W0L,92E
.................... 				clear_interrupt(INT_TIMER4); 
296A:  BCLR.B  87.3
.................... 				enable_interrupts(INT_TIMER4); 
296C:  BSET.B  97.3
.................... 			} 
....................         	EnableIntr ();	 
296E:  CALL    23D4
....................             //sendTx1Count = SendTx1 (((int8u *)DestPtrStruct.blockPtr)); 
.................... 			printf("[e]"); 
2972:  BTSC.B  223.1
2974:  BRA     2972
2976:  MOV     #5B,W4
2978:  MOV     W4,224
297A:  BTSC.B  223.1
297C:  BRA     297A
297E:  MOV     #65,W4
2980:  MOV     W4,224
2982:  BTSC.B  223.1
2984:  BRA     2982
2986:  MOV     #5D,W4
2988:  MOV     W4,224
298A:  PUSH    42
298C:  BCLR.B  81.7
298E:  SETM.B  42
2990:  BSET.B  81.7
....................             //putc('F'); 
....................             free ((void *)DestPtrStruct.blockPtr); 
2992:  PUSH    9EC
2994:  POP     B00
2996:  CALL    F52
299A:  BCLR.B  81.7
299C:  POP     42
299E:  BSET.B  81.7
....................             MemCount--; 
29A0:  DEC     09F0
....................             //EnableIntr(); 
....................         } 
29A2:  BRA     29A8
....................         else 
....................         { 
....................             EnableIntr(); 
29A4:  CALL    23D4
....................         } 
29A8:  BRA     28EE
....................     } 
....................     return 0; 
29AA:  CLR     0
.................... } 
....................  
29AC:  PWRSAV  #0
.................... static void HardwareInit (void) 
*
223E:  MOV     W5,[W15++]
.................... { 
.................... 	setup_adc_ports(NO_ANALOGS); 
2240:  SETM    32C
.................... 	set_tris_a (get_tris_a () & 0xffe8); //1111 1111 1110 1000 
2242:  MOV     2C0,W5
2244:  MOV     #FFE8,W0
2246:  AND     W0,W5,W5
2248:  MOV     W5,2C0
.................... 	set_tris_b (get_tris_b () & 0xff3f); //1111 1111 0011 1111 
224A:  MOV     2C8,W5
224C:  MOV     #FF3F,W0
224E:  AND     W0,W5,W5
2250:  MOV     W5,2C8
.................... 	B0 = (ReadPortB & 0x0001); 
2252:  MOV     91E,W0
2254:  AND     W0,#1,W0
2256:  MOV     W0,920
.................... 	B1 = (ReadPortB & 0x0002) >> 1; 
2258:  MOV     91E,W0
225A:  AND     W0,#2,W5
225C:  MOV     W5,922
225E:  LSR     922
.................... 	B2 = (ReadPortB & 0x0004) >> 2; 
2260:  MOV     91E,W0
2262:  AND     W0,#4,W5
2264:  MOV     W5,924
2266:  LSR     924
2268:  LSR     924
.................... 	B3 = (ReadPortB & 0x0008) >> 3; 
226A:  MOV     91E,W0
226C:  AND     W0,#8,W5
226E:  MOV     W5,926
2270:  LSR     926
2272:  LSR     926
2274:  LSR     926
....................  
.................... 	setup_capture(1,CAPTURE_EE | INTERRUPT_EVERY_CAPTURE |CAPTURE_TIMER2); 
2276:  MOV     #81,W4
2278:  MOV     W4,142
.................... 	clear_interrupt(INT_IC1); 
227A:  BCLR.B  84.1
.................... 	enable_interrupts(INT_IC1); 
227C:  BSET.B  94.1
.................... 	 
.................... 	setup_capture(2,CAPTURE_EE | INTERRUPT_EVERY_CAPTURE |CAPTURE_TIMER2); 
227E:  MOV     #81,W4
2280:  MOV     W4,146
.................... 	clear_interrupt(INT_IC2); 
2282:  BCLR.B  84.5
.................... 	enable_interrupts(INT_IC2); 
2284:  BSET.B  94.5
....................  
.................... 	setup_capture(3,CAPTURE_EE | INTERRUPT_EVERY_CAPTURE |CAPTURE_TIMER2); 
2286:  MOV     #81,W4
2288:  MOV     W4,14A
.................... 	clear_interrupt(INT_IC3); 
228A:  BCLR.B  88.5
.................... 	enable_interrupts(INT_IC3); 
228C:  BSET.B  98.5
....................  
.................... 	setup_capture(4,CAPTURE_EE | INTERRUPT_EVERY_CAPTURE |CAPTURE_TIMER2); 
228E:  MOV     #81,W4
2290:  MOV     W4,14E
.................... 	clear_interrupt(INT_IC4); 
2292:  BCLR.B  88.6
.................... 	enable_interrupts(INT_IC4); 
2294:  BSET.B  98.6
....................  
.................... 	clear_interrupt(INT_EXT1); 
2296:  BCLR.B  86.4
.................... 	enable_interrupts(INT_EXT1); 
2298:  BSET.B  96.4
.................... 	 
.................... 	clear_interrupt(INT_EXT2); 
229A:  BCLR.B  87.5
.................... 	enable_interrupts(INT_EXT2); 
229C:  BSET.B  97.5
....................  
.................... 	duty1 = START_DUTY; 
229E:  CLR     8FA
.................... 	set_compare_time(1, duty1, duty1); 
22A0:  PUSH    8FA
22A2:  POP     182
22A4:  PUSH    8FA
22A6:  POP     180
.................... 	setup_compare(1, COMPARE_PWM | COMPARE_TIMER3); 
22A8:  MOV     #E,W4
22AA:  MOV     W4,184
....................  
.................... 	set_compare_time(2, duty1, duty1); 
22AC:  PUSH    8FA
22AE:  POP     188
22B0:  PUSH    8FA
22B2:  POP     186
.................... 	setup_compare(2, COMPARE_PWM | COMPARE_TIMER3); 
22B4:  MOV     #E,W4
22B6:  MOV     W4,18A
.................... 	 
.................... 	set_timer1(0); 
22B8:  CLR     100
.................... 	setup_timer1(TMR_INTERNAL | TMR_DIV_BY_256, 6249); 	 
22BA:  CLR     104
22BC:  MOV     #1869,W4
22BE:  MOV     W4,102
22C0:  MOV     #8030,W4
22C2:  MOV     W4,104
.................... 	 
.................... 	set_timer2(0); 
22C4:  CLR     106
.................... 	setup_timer2(TMR_INTERNAL | TMR_DIV_BY_1, 65535); 
22C6:  CLR     110
22C8:  SETM    10C
22CA:  MOV     #8000,W4
22CC:  MOV     W4,110
....................  
.................... 	set_timer3(0); 
22CE:  CLR     10A
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_1, 400); 
22D0:  CLR     112
22D2:  MOV     #190,W4
22D4:  MOV     W4,10E
22D6:  MOV     #8000,W4
22D8:  MOV     W4,112
....................  
.................... 	set_timer4(0); 
22DA:  CLR     114
.................... 	setup_timer4 (TMR_INTERNAL | TMR_DIV_BY_256, 6249); 
22DC:  CLR     11E
22DE:  MOV     #1869,W4
22E0:  MOV     W4,11A
22E2:  MOV     #8030,W4
22E4:  MOV     W4,11E
....................  
.................... 	set_timer5(0); 
22E6:  CLR     118
.................... 	setup_timer5 (TMR_INTERNAL | TMR_DIV_BY_256, 624); 
22E8:  CLR     120
22EA:  MOV     #270,W4
22EC:  MOV     W4,11C
22EE:  MOV     #8030,W4
22F0:  MOV     W4,120
.................... 	return; 
22F2:  MOV     [--W15],W5
22F4:  RETURN  
.................... } 
....................  
.................... static void GlobalVarInit (void) 
.................... { 
....................     Tx1Flag = TX1_READY; 
22F6:  BSET.B  92F.0
....................     TxBuffIdx = 0; 
22F8:  CLR     9C2
....................     Tx1FrameIn = 0; 
22FA:  CLR     9C4
....................     Tx1QFullCount = 0; 
22FC:  CLR     9CC
....................     Rx1FrameCount = 0; 
22FE:  CLR     9C8
....................     RxCount = 0; 
2300:  CLR     9CA
....................     Rx1QFullCount = 0; 
2302:  CLR     9CE
....................     MemFail = 0; 
2304:  CLR     9EE
....................     MemCount = 0; 
2306:  CLR     9F0
....................     return; 
2308:  RETURN  
.................... } 
.................... static void DynamicMemInit (void) 
230A:  PUSH    42
230C:  BCLR.B  81.7
230E:  SETM.B  42
2310:  BSET.B  81.7
.................... { 
....................     //get mem block for first Rx1 buffer 
....................     RxBuffPtr = (int8u *)malloc ((sizeof (int8u)) * RX_CMND_FRM_LN); 
2312:  MOV     #19,W4
2314:  MOV     W4,B08
2316:  CALL    FEC
231A:  BCLR.B  81.7
231C:  POP     42
231E:  BSET.B  81.7
2320:  MOV     W0,9D0
....................     if (RxBuffPtr != (int8u *)NULL) 
2322:  CP0     9D0
2324:  BRA     Z,2332
....................     { 
....................         MemCount++; 
2326:  INC     09F0
....................         clear_interrupt(INT_RDA); 
2328:  REPEAT  #3
232A:  MOV     226,W0
232C:  BCLR.B  85.3
....................         enable_interrupts (INT_RDA); 
232E:  BSET.B  95.3
....................     } 
2330:  BRA     2334
....................     else 
....................     { 
....................         MemFail++; 
2332:  INC     09EE
....................     } 
....................     return; 
2334:  RETURN  
.................... } 
.................... static void UARTQueueInit (void) 
.................... { 
....................     QPtrXInit(&Rx1QCB, Rx1BuffPtrArray, RX1Q_LN); 
*
23B2:  MOV     #9D2,W4
23B4:  MOV     W4,ABE
23B6:  MOV     #9DC,W4
23B8:  MOV     W4,AC0
23BA:  MOV     #8,W4
23BC:  MOV     W4,AC2
23BE:  CALL    2336
....................     Q8UXInit(&Tx1QCB, Tx1QArray, TX1Q_LN); 
23C2:  MOV     #936,W4
23C4:  MOV     W4,ABE
23C6:  MOV     #940,W4
23C8:  MOV     W4,AC0
23CA:  MOV     #80,W4
23CC:  MOV     W4,AC2
23CE:  CALL    2374
....................     return; 
23D2:  RETURN  
.................... } 
.................... static int8u SendTx1 (int8u *strPtr)//critical section 
.................... { 
....................     int8u strLn; 
....................     int8u strIdx; 
....................     int8u qSpace; 
....................     int8u errCode; 
....................     int8u count; 
....................     count = 0; 
....................     strLn = strlen(strPtr); 
....................     if (strLn != 0) 
....................     { 
....................         qSpace = TX1Q_LN - Q8UXCount (&Tx1QCB); 
....................         if (qSpace >= (int16u)strLn) 
....................         { 
....................             for (strIdx = 0; strIdx < strLn; strIdx++) 
....................             { 
....................                 Q8UXPut (&Tx1QCB, strPtr[strIdx], &errCode); 
....................                 count++; 
....................             } 
....................             if (Tx1Flag == TX1_READY) 
....................             { 
....................                 Tx1Flag = TX1_BUSY; // Set Rx1 to Busy. 
....................                 TX1IF = 1;// Start Tx1 Interupt.  
....................                 enable_interrupts(INT_TBE); 
....................             } 
....................         } 
....................     } 
....................     return count; 
.................... } 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                               My Function                              **/ 
.................... /****************************************************************************/ 
.................... static void create_position_array(void) 
*
2568:  MOV     W5,[W15++]
256A:  CLR     ABE
256C:  CLR     AC0
256E:  CLR     AC2
2570:  CLR     AC4
2572:  CLR     AC6
2574:  CLR     AC8
2576:  CLR     ACA
2578:  CLR     AD0
.................... { 
....................     int16u c_state = 0; 
....................     int16u s_state = 0; 
....................     int16u sum_a = 0;  
....................     int16u sum_b = 0; 
....................     int16u sum_c = 0; 
.................... 	int16u sum_d = 0; 
....................     int16u pos_r = 0; 
....................     int *posY; 
....................     int *posX; 
....................     int16u Arr_state = 0; 
....................  
....................     posY = position_y; 
257A:  MOV     #A56,W4
257C:  MOV     W4,ACC
....................     posX = position_x; 
257E:  MOV     #9F2,W4
2580:  MOV     W4,ACE
....................  
....................     for(int8u i = 0; i < strlen(DestPtrStruct.blockPtr); i++) 
2582:  CLR.B   AD2
2584:  PUSH    9EC
2586:  POP     ADC
2588:  CALL    2446
258C:  MOV     AD2,W4
258E:  CP.B    W4L,W0L
2590:  BRA     C,275C
....................     { 
....................         if(DestPtrStruct.blockPtr[i] == CONDITION_S) 
2592:  MOV     AD2,W4
2594:  CLR.B   9
2596:  MOV     W4,W0
2598:  ADD     9EC,W0
259A:  MOV.B   [W0],W4L
259C:  XOR.B   #28,W4L
259E:  BRA     NZ,25A6
....................         { 
....................             c_state = 1; 
25A0:  MOV     #1,W4
25A2:  MOV     W4,ABE
....................         } 
25A4:  BRA     2758
....................         else if(DestPtrStruct.blockPtr[i] == CONDITION_M) 
25A6:  MOV     AD2,W4
25A8:  CLR.B   9
25AA:  MOV     W4,W0
25AC:  ADD     9EC,W0
25AE:  MOV.B   [W0],W4L
25B0:  XOR.B   #2C,W4L
25B2:  BRA     NZ,2650
....................         { 
....................             if(c_state == 1) 
25B4:  MOV     ABE,W4
25B6:  CP      W4,#1
25B8:  BRA     NZ,264E
....................             { 
....................                 //Found x 
....................                 if(s_state==1){pos_r = sum_a;} 
25BA:  MOV     AC0,W4
25BC:  CP      W4,#1
25BE:  BRA     NZ,25C4
25C0:  PUSH    AC2
25C2:  POP     ACA
....................                 if(s_state==2){pos_r = sum_a*10+sum_b;} 
25C4:  MOV     AC0,W4
25C6:  CP      W4,#2
25C8:  BRA     NZ,25D6
25CA:  MOV     AC2,W4
25CC:  MUL.UU  W4,#A,W0
25CE:  MOV     W0,W5
25D0:  MOV     W5,W0
25D2:  ADD     AC4,W0
25D4:  MOV     W0,ACA
....................                 if(s_state==3){pos_r = sum_a*100+sum_b*10+sum_c;} 
25D6:  MOV     AC0,W4
25D8:  CP      W4,#3
25DA:  BRA     NZ,25F0
25DC:  MOV     AC2,W4
25DE:  MOV     #64,W3
25E0:  MUL.UU  W4,W3,W0
25E2:  MOV     W0,W5
25E4:  MOV     AC4,W4
25E6:  MUL.UU  W4,#A,W0
25E8:  ADD     W0,W5,W5
25EA:  MOV     W5,W0
25EC:  ADD     AC6,W0
25EE:  MOV     W0,ACA
.................... 				if(s_state==4){pos_r = sum_a*1000+sum_b*100+sum_c*10+sum_d;} 
25F0:  MOV     AC0,W4
25F2:  CP      W4,#4
25F4:  BRA     NZ,2612
25F6:  MOV     AC2,W4
25F8:  MOV     #3E8,W3
25FA:  MUL.UU  W4,W3,W0
25FC:  MOV     W0,W5
25FE:  MOV     AC4,W4
2600:  MOV     #64,W3
2602:  MUL.UU  W4,W3,W0
2604:  ADD     W0,W5,W5
2606:  MOV     AC6,W4
2608:  MUL.UU  W4,#A,W0
260A:  ADD     W0,W5,W5
260C:  MOV     W5,W0
260E:  ADD     AC8,W0
2610:  MOV     W0,ACA
....................                 printf("\r\n x == %d", pos_r); 
2612:  MOV     #0,W1
2614:  MOV     W1,W0
2616:  CLR.B   1
2618:  CALL    DFC
261C:  INC     W1,W1
261E:  BTSC.B  223.1
2620:  BRA     261E
2622:  MOV     W0,224
2624:  MOV     #7,W0
2626:  CPSGT   W1,W0
2628:  BRA     2614
262A:  MOV     ACA,W0
262C:  MOV     #0,W4
262E:  CALL    2468
.................... 				DistanceX = pos_r/10; 
2632:  MOV     ACA,W4
2634:  MOV     #A,W3
2636:  REPEAT  #11
2638:  DIV.U   W4,W3
263A:  MOV     W0,90C
....................                 *(posX+Arr_state) = pos_r; 
263C:  MOV     AD0,W0
263E:  SL      W0,#1,W0
2640:  MOV     ACE,W4
2642:  ADD     W0,W4,W0
2644:  MOV     W0,W5
2646:  MOV     ACA,W4
2648:  MOV     W4,[W5+#0]
....................                 s_state = 0; 
264A:  CLR     AC0
....................                 c_state = 0; 
264C:  CLR     ABE
....................             } 
....................         } 
264E:  BRA     2758
....................         else if(DestPtrStruct.blockPtr[i] == CONDITION_E) 
2650:  MOV     AD2,W4
2652:  CLR.B   9
2654:  MOV     W4,W0
2656:  ADD     9EC,W0
2658:  MOV.B   [W0],W4L
265A:  XOR.B   #29,W4L
265C:  BRA     NZ,26FE
....................         { 
....................             //Found y 
....................             if(s_state==1){pos_r = sum_a;} 
265E:  MOV     AC0,W4
2660:  CP      W4,#1
2662:  BRA     NZ,2668
2664:  PUSH    AC2
2666:  POP     ACA
....................             if(s_state==2){pos_r = sum_a*10+sum_b;} 
2668:  MOV     AC0,W4
266A:  CP      W4,#2
266C:  BRA     NZ,267A
266E:  MOV     AC2,W4
2670:  MUL.UU  W4,#A,W0
2672:  MOV     W0,W5
2674:  MOV     W5,W0
2676:  ADD     AC4,W0
2678:  MOV     W0,ACA
....................             if(s_state==3){pos_r = sum_a*100+sum_b*10+sum_c;} 
267A:  MOV     AC0,W4
267C:  CP      W4,#3
267E:  BRA     NZ,2694
2680:  MOV     AC2,W4
2682:  MOV     #64,W3
2684:  MUL.UU  W4,W3,W0
2686:  MOV     W0,W5
2688:  MOV     AC4,W4
268A:  MUL.UU  W4,#A,W0
268C:  ADD     W0,W5,W5
268E:  MOV     W5,W0
2690:  ADD     AC6,W0
2692:  MOV     W0,ACA
.................... 			if(s_state==4){pos_r = sum_a*1000+sum_b*100+sum_c*10+sum_d;} 
2694:  MOV     AC0,W4
2696:  CP      W4,#4
2698:  BRA     NZ,26B6
269A:  MOV     AC2,W4
269C:  MOV     #3E8,W3
269E:  MUL.UU  W4,W3,W0
26A0:  MOV     W0,W5
26A2:  MOV     AC4,W4
26A4:  MOV     #64,W3
26A6:  MUL.UU  W4,W3,W0
26A8:  ADD     W0,W5,W5
26AA:  MOV     AC6,W4
26AC:  MUL.UU  W4,#A,W0
26AE:  ADD     W0,W5,W5
26B0:  MOV     W5,W0
26B2:  ADD     AC8,W0
26B4:  MOV     W0,ACA
....................             printf("\r\n y == %d", pos_r); 
26B6:  MOV     #0,W1
26B8:  MOV     W1,W0
26BA:  CLR.B   1
26BC:  CALL    E14
26C0:  INC     W1,W1
26C2:  BTSC.B  223.1
26C4:  BRA     26C2
26C6:  MOV     W0,224
26C8:  MOV     #7,W0
26CA:  CPSGT   W1,W0
26CC:  BRA     26B8
26CE:  MOV     ACA,W0
26D0:  MOV     #0,W4
26D2:  CALL    2468
.................... 			DistanceY = pos_r/10; 
26D6:  MOV     ACA,W4
26D8:  MOV     #A,W3
26DA:  REPEAT  #11
26DC:  DIV.U   W4,W3
26DE:  MOV     W0,90E
....................             *(posY+Arr_state) = pos_r; 
26E0:  MOV     AD0,W0
26E2:  SL      W0,#1,W0
26E4:  MOV     ACC,W4
26E6:  ADD     W0,W4,W0
26E8:  MOV     W0,W5
26EA:  MOV     ACA,W4
26EC:  MOV     W4,[W5+#0]
....................             s_state = 0; 
26EE:  CLR     AC0
....................             Arr_state++; 
26F0:  INC     0AD0
.................... 			move_state = 'w'; 
26F2:  MOV.B   #77,W0L
26F4:  MOV.B   W0L,92E
.................... 			send_end = 0; 
26F6:  CLR     934
.................... 			clear_interrupt(INT_TIMER4); 
26F8:  BCLR.B  87.3
.................... 			enable_interrupts(INT_TIMER4); 
26FA:  BSET.B  97.3
....................         } 
26FC:  BRA     2758
....................         else 
....................         { 
....................             //Found numeric 
....................             //printf("\r\nDestPtrStruct.blockPtr[i] = %c", DestPtrStruct.blockPtr[i]); 
....................             if(s_state == 0){sum_a = ConvertStr2Int(DestPtrStruct.blockPtr[i]);} 
26FE:  CP0     AC0
2700:  BRA     NZ,271A
2702:  MOV     AD2,W4
2704:  CLR.B   9
2706:  MOV     W4,W0
2708:  ADD     9EC,W0
270A:  MOV.B   [W0],W5L
270C:  PUSH    ADE
270E:  MOV.B   W5L,[W15-#2]
2710:  POP     ADE
2712:  CALL    255E
2716:  MOV.B   W0L,AC2
2718:  CLR.B   AC3
....................             if(s_state == 1){sum_b = ConvertStr2Int(DestPtrStruct.blockPtr[i]);} 
271A:  MOV     AC0,W4
271C:  CP      W4,#1
271E:  BRA     NZ,2738
2720:  MOV     AD2,W4
2722:  CLR.B   9
2724:  MOV     W4,W0
2726:  ADD     9EC,W0
2728:  MOV.B   [W0],W5L
272A:  PUSH    ADE
272C:  MOV.B   W5L,[W15-#2]
272E:  POP     ADE
2730:  CALL    255E
2734:  MOV.B   W0L,AC4
2736:  CLR.B   AC5
....................             if(s_state == 2){sum_c = ConvertStr2Int(DestPtrStruct.blockPtr[i]);} 
2738:  MOV     AC0,W4
273A:  CP      W4,#2
273C:  BRA     NZ,2756
273E:  MOV     AD2,W4
2740:  CLR.B   9
2742:  MOV     W4,W0
2744:  ADD     9EC,W0
2746:  MOV.B   [W0],W5L
2748:  PUSH    ADE
274A:  MOV.B   W5L,[W15-#2]
274C:  POP     ADE
274E:  CALL    255E
2752:  MOV.B   W0L,AC6
2754:  CLR.B   AC7
....................             s_state++; 
2756:  INC     0AC0
....................         } 
2758:  INC.B   0AD2
275A:  BRA     2584
....................     } 
....................     return; 
275C:  MOV     [--W15],W5
275E:  RETURN  
.................... }         
....................  
.................... static int8u ConvertStr2Int (int8u num) 
.................... { 
.................... 	return num - '0'; 
*
255E:  MOV     ADE,W4
2560:  SUB.B   #30,W4L
2562:  MOV.B   W4L,W0L
2564:  MOV.B   W0L,0
2566:  RETURN  
.................... } 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                           Interrupt Functions                          **/ 
.................... /****************************************************************************/ 
....................  
.................... #INT_RDA //Rx1 interupt 
.................... void RDA1 (void) 
*
109E:  PUSH    42
10A0:  PUSH    36
10A2:  PUSH    32
10A4:  MOV     W0,[W15++]
10A6:  MOV     #2,W0
10A8:  REPEAT  #C
10AA:  MOV     [W0++],[W15++]
.................... { 
....................     static FRAME_STATE FrameState = FRAME_WAIT; 
....................     static int16u FrmIdx = 0; 
....................     int8u Chr; 
....................     int8u *errCode; 
....................  
....................     Chr = getc(); // Read data from Rx1 register 
10AC:  BTSS.B  222.0
10AE:  BRA     10AC
10B0:  MOV     226,W0
10B2:  MOV.B   W0L,AF6
....................     RxCount++; 
10B4:  INC     09CA
....................     switch (FrameState) // State machine for build frame 
10B6:  CLR     W0
10B8:  BTSC.B  92F.1
10BA:  INC     W0,W0
10BC:  CLR.B   1
10BE:  XOR     #0,W0
10C0:  BRA     Z,10C8
10C2:  XOR     #1,W0
10C4:  BRA     Z,10D2
10C6:  BRA     1140
....................     { 
....................         case FRAME_WAIT: // waits for start char of new frame 
....................             if (Chr == START_CHR) 
10C8:  MOV     AF6,W4
10CA:  XOR.B   #5B,W4L
10CC:  BRA     NZ,10D0
....................             { 
....................                 //Get a start char 
....................                 //RxBuffPtr[FrmIdx] = Chr; // Save start char to frame 
....................                 //FrmIdx++; 
....................                 FrameState = FRAME_PROGRESS; // Change state to build frame 
10CE:  BSET.B  92F.1
....................             } 
....................             break; 
10D0:  BRA     1142
....................         case FRAME_PROGRESS: // Build frame 
....................             if ((FrmIdx == (RX_CMND_FRM_LN - 2)) && (Chr != END_CHR)) 
10D2:  MOV     ABA,W4
10D4:  CP      W4,#17
10D6:  BRA     NZ,10E4
10D8:  MOV     AF6,W4
10DA:  XOR.B   #5D,W4L
10DC:  BRA     Z,10E4
....................             { 
....................                 //Characters exceed frame lenght. Frame error. 
....................                 // Rejects data and black to wait new frame. 
....................                 FrmIdx = 0; 
10DE:  CLR     ABA
....................                 FrameState = FRAME_WAIT; 
10E0:  BCLR.B  92F.1
....................             } 
10E2:  BRA     113E
....................             else if (Chr == END_CHR) 
10E4:  MOV     AF6,W4
10E6:  XOR.B   #5D,W4L
10E8:  BRA     NZ,1132
....................             { 
....................                 //Get and char. Frame completes. 
....................                 //RxBuffPtr[FrmIdx] = Chr; 
....................                 //FrmIdx++; 
....................                 RxBuffPtr[FrmIdx] = 0; 
10EA:  MOV     ABA,W0
10EC:  ADD     9D0,W0
10EE:  MOV     W0,W5
10F0:  CLR.B   [W5]
....................                 FrmIdx = 0; 
10F2:  CLR     ABA
....................                 Rx1FrameCount++; 
10F4:  INC     09C8
....................                 //Sends Rx1 event to event queue. 
....................                 QPtrXPut (&Rx1QCB, (void *)RxBuffPtr, &errCode); 
10F6:  MOV     #9D2,W4
10F8:  MOV     W4,B02
10FA:  PUSH    9D0
10FC:  POP     B04
10FE:  MOV     #AF8,W4
1100:  MOV     W4,B06
1102:  CALL    E2C
....................                 if (errCode == Q_FULL) 
1106:  MOV     AF8,W4
1108:  CP      W4,#1
110A:  BRA     NZ,1118
....................                 { 
....................                     //EvQ full error. Free mem of data block. 
....................                     free ((void *)RxBuffPtr); 
110C:  PUSH    9D0
110E:  POP     B00
1110:  CALL    F52
....................                     MemCount--; 
1114:  DEC     09F0
....................                     Rx1QFullCount++; 
1116:  INC     09CE
....................                 } 
....................                 FrameState = FRAME_WAIT; // Back to wait for start char of new frame. 
1118:  BCLR.B  92F.1
....................                 // GEt mem block for better of new frame 
....................                 RxBuffPtr = (int8u *)malloc ((sizeof (int8u)) * RX_CMND_FRM_LN); 
111A:  MOV     #19,W4
111C:  MOV     W4,B08
111E:  CALL    FEC
1122:  MOV     W0,9D0
....................                 if (RxBuffPtr == (int8u *)NULL) 
1124:  CP0     9D0
1126:  BRA     NZ,112E
....................                 { 
....................                     //Can not get mem block. Disable Rx1 interupt. 
....................                     disable_interrupts(INT_RDA); 
1128:  BCLR.B  95.3
....................                     MemFail++; 
112A:  INC     09EE
....................                 } 
112C:  BRA     1130
....................                 else 
....................                 { 
....................                     MemCount++; 
112E:  INC     09F0
....................                 } 
....................             } 
1130:  BRA     113E
....................             else 
....................             { 
....................                 RxBuffPtr[FrmIdx] = Chr; 
1132:  MOV     ABA,W0
1134:  ADD     9D0,W0
1136:  MOV     W0,W5
1138:  MOV     AF6,W0
113A:  MOV.B   W0L,[W5+#0]
....................                 FrmIdx++; 
113C:  INC     0ABA
....................             } 
....................             break; 
113E:  BRA     1142
....................         default: 
....................             break; 
1140:  BRA     1142
....................     } 
....................     return; 
.................... } 
....................  
1142:  BCLR.B  85.3
1144:  MOV     #1A,W0
1146:  REPEAT  #C
1148:  MOV     [--W15],[W0--]
114A:  MOV     [--W15],W0
114C:  POP     32
114E:  POP     36
1150:  POP     42
1152:  RETFIE  
.................... #INT_TBE // Tx1 interupt 
.................... void TBE1ISR (void) 
*
11B8:  BCLR.B  85.4
11BA:  PUSH    42
11BC:  PUSH    36
11BE:  PUSH    32
11C0:  MOV     W0,[W15++]
11C2:  MOV     #2,W0
11C4:  REPEAT  #C
11C6:  MOV     [W0++],[W15++]
.................... { 
....................     int8u destChr; 
....................     Q_ERR errCode; 
....................     Q8UXGet (&Tx1QCB, &destChr, &errCode); 
11C8:  MOV     #936,W4
11CA:  MOV     W4,AF8
11CC:  MOV     #AF6,W4
11CE:  MOV     W4,AFA
11D0:  MOV     #AF7,W4
11D2:  MOV     W4,AFC
11D4:  CALL    1154
....................     if (errCode == Q_OK) 
11D8:  CP0.B   AF7
11DA:  BRA     NZ,11E8
....................     { 
....................         putc(destChr); 
11DC:  MOV.B   AF6,W0L
11DE:  BTSC.B  223.1
11E0:  BRA     11DE
11E2:  MOV.B   W0L,224
11E4:  CLR.B   225
....................     } 
11E6:  BRA     11EC
....................     else 
....................     { 
....................         disable_interrupts (INT_TBE); 
11E8:  BCLR.B  95.4
....................         Tx1Flag = TX1_READY; 
11EA:  BSET.B  92F.0
....................     } 
....................     return; 
.................... } 
....................  
11EC:  MOV     #1A,W0
11EE:  REPEAT  #C
11F0:  MOV     [--W15],[W0--]
11F2:  MOV     [--W15],W0
11F4:  POP     32
11F6:  POP     36
11F8:  POP     42
11FA:  RETFIE  
.................... #INT_TIMER1 
.................... void Home(void){ 
*
1280:  PUSH    42
1282:  PUSH    36
1284:  PUSH    32
1286:  MOV     W0,[W15++]
1288:  MOV     #2,W0
128A:  REPEAT  #C
128C:  MOV     [W0++],[W15++]
.................... 	if(home_state == 1){ 
128E:  MOV     92C,W4
1290:  CP      W4,#1
1292:  BRA     NZ,12B6
.................... 		drive_motor(MOTOR_R,CCW,100); 
1294:  MOV     #2,W4
1296:  MOV     W4,B52
1298:  MOV     #2,W4
129A:  MOV     W4,B54
129C:  MOV     #64,W4
129E:  MOV     W4,B56
12A0:  CALL    11FC
.................... 		drive_motor(MOTOR_L,CCW,100); 
12A4:  MOV     #1,W4
12A6:  MOV     W4,B52
12A8:  MOV     #2,W4
12AA:  MOV     W4,B54
12AC:  MOV     #64,W4
12AE:  MOV     W4,B56
12B0:  CALL    11FC
.................... 	} 
12B4:  BRA     1318
.................... 	else if(home_state == 2){ 
12B6:  MOV     92C,W4
12B8:  CP      W4,#2
12BA:  BRA     NZ,12DE
.................... 		drive_motor(MOTOR_R,CW,100); 
12BC:  MOV     #2,W4
12BE:  MOV     W4,B52
12C0:  MOV     #1,W4
12C2:  MOV     W4,B54
12C4:  MOV     #64,W4
12C6:  MOV     W4,B56
12C8:  CALL    11FC
.................... 		drive_motor(MOTOR_L,CCW,100); 
12CC:  MOV     #1,W4
12CE:  MOV     W4,B52
12D0:  MOV     #2,W4
12D2:  MOV     W4,B54
12D4:  MOV     #64,W4
12D6:  MOV     W4,B56
12D8:  CALL    11FC
.................... 	} 
12DC:  BRA     1318
.................... 	else if(home_state == 3){ 
12DE:  MOV     92C,W4
12E0:  CP      W4,#3
12E2:  BRA     NZ,1318
.................... 		home_state = 0; 
12E4:  CLR     92C
.................... 		drive_motor(MOTOR_R,STOP,0); 
12E6:  MOV     #2,W4
12E8:  MOV     W4,B52
12EA:  CLR     B54
12EC:  CLR     B56
12EE:  CALL    11FC
.................... 		drive_motor(MOTOR_L,STOP,0); 
12F2:  MOV     #1,W4
12F4:  MOV     W4,B52
12F6:  CLR     B54
12F8:  CLR     B56
12FA:  CALL    11FC
.................... 		printf("[h]"); 
12FE:  BTSC.B  223.1
1300:  BRA     12FE
1302:  MOV     #5B,W4
1304:  MOV     W4,224
1306:  BTSC.B  223.1
1308:  BRA     1306
130A:  MOV     #68,W4
130C:  MOV     W4,224
130E:  BTSC.B  223.1
1310:  BRA     130E
1312:  MOV     #5D,W4
1314:  MOV     W4,224
.................... 		disable_interrupts(INT_TIMER1); 
1316:  BCLR.B  94.3
.................... 	} 
.................... 	return; 
.................... } 
....................  
1318:  BCLR.B  84.3
131A:  MOV     #1A,W0
131C:  REPEAT  #C
131E:  MOV     [--W15],[W0--]
1320:  MOV     [--W15],W0
1322:  POP     32
1324:  POP     36
1326:  POP     42
1328:  RETFIE  
.................... #INT_EXT1 
.................... void Initial_Y_axis(void){ 
132A:  PUSH    42
132C:  PUSH    36
132E:  PUSH    32
1330:  MOV     W0,[W15++]
1332:  MOV     #2,W0
1334:  REPEAT  #C
1336:  MOV     [W0++],[W15++]
.................... 	count_pulseX = 0; 
1338:  CLR     8FC
133A:  CLR     8FE
.................... 	count_pulseY = 0; 
133C:  CLR     900
133E:  CLR     902
.................... 	thetaY = 0; 
1340:  CLR     908
1342:  CLR     90A
.................... 	current_posY = 0; 
1344:  CLR     91A
1346:  CLR     91C
.................... 	home_state = 3; 
1348:  MOV     #3,W4
134A:  MOV     W4,92C
.................... 	return; 
.................... } 
134C:  BCLR.B  86.4
134E:  MOV     #1A,W0
1350:  REPEAT  #C
1352:  MOV     [--W15],[W0--]
1354:  MOV     [--W15],W0
1356:  POP     32
1358:  POP     36
135A:  POP     42
135C:  RETFIE  
.................... #INT_EXT2 
.................... void Initial_X_axis(void){ 
135E:  PUSH    42
1360:  PUSH    36
1362:  PUSH    32
1364:  MOV     W0,[W15++]
1366:  MOV     #2,W0
1368:  REPEAT  #C
136A:  MOV     [W0++],[W15++]
.................... 	count_pulseX = 0; 
136C:  CLR     8FC
136E:  CLR     8FE
.................... 	count_pulseY = 0; 
1370:  CLR     900
1372:  CLR     902
.................... 	thetaX = 0; 
1374:  CLR     904
1376:  CLR     906
.................... 	current_posX = 0; 
1378:  CLR     916
137A:  CLR     918
.................... 	home_state = 2; 
137C:  MOV     #2,W4
137E:  MOV     W4,92C
.................... 	return; 
.................... }	 
....................  
1380:  BCLR.B  87.5
1382:  MOV     #1A,W0
1384:  REPEAT  #C
1386:  MOV     [--W15],[W0--]
1388:  MOV     [--W15],W0
138A:  POP     32
138C:  POP     36
138E:  POP     42
1390:  RETFIE  
.................... #INT_IC1 
.................... void Encoder1_A(void){ 
1392:  PUSH    42
1394:  PUSH    36
1396:  PUSH    32
1398:  MOV     W0,[W15++]
139A:  MOV     #2,W0
139C:  REPEAT  #C
139E:  MOV     [W0++],[W15++]
.................... 	ReadPortB = input_b() & 0x0003;   
13A0:  MOV     2CA,W5
13A2:  AND     W5,#3,W0
13A4:  MOV     W0,91E
.................... 	B0 = (ReadPortB & 0x0001); 
13A6:  MOV     91E,W0
13A8:  AND     W0,#1,W0
13AA:  MOV     W0,920
.................... 	if((B0 ^ B1) == 0){ 
13AC:  MOV     920,W0
13AE:  XOR     922,W0
13B0:  MOV     W0,W5
13B2:  CP0     W5
13B4:  BRA     NZ,13BE
.................... 		count_pulseX--; 
13B6:  DEC     08FC
13B8:  BTSS.B  42.0
13BA:  DEC     08FE
.................... 	} 
13BC:  BRA     13C4
.................... 	else{ 
.................... 		count_pulseX++; 
13BE:  INC     08FC
13C0:  BTSC.B  42.1
13C2:  INC     08FE
.................... 	} 
.................... 	//printf("\ncount_pulseX = %d",count_pulseX); 
.................... 	return; 
.................... } 
....................  
13C4:  BCLR.B  84.1
13C6:  MOV     #1A,W0
13C8:  REPEAT  #C
13CA:  MOV     [--W15],[W0--]
13CC:  MOV     [--W15],W0
13CE:  POP     32
13D0:  POP     36
13D2:  POP     42
13D4:  RETFIE  
.................... #INT_IC2 
.................... void Encoder1_B(void){ 
13D6:  PUSH    42
13D8:  PUSH    36
13DA:  PUSH    32
13DC:  MOV     W0,[W15++]
13DE:  MOV     #2,W0
13E0:  REPEAT  #C
13E2:  MOV     [W0++],[W15++]
.................... 	ReadPortB = input_b() & 0x0003;   
13E4:  MOV     2CA,W5
13E6:  AND     W5,#3,W0
13E8:  MOV     W0,91E
.................... 	B1 = (ReadPortB & 0x0002 ) >> 1; 
13EA:  MOV     91E,W0
13EC:  AND     W0,#2,W5
13EE:  MOV     W5,922
13F0:  LSR     922
.................... 	if((B0 ^ B1) == 0){ 
13F2:  MOV     920,W0
13F4:  XOR     922,W0
13F6:  MOV     W0,W5
13F8:  CP0     W5
13FA:  BRA     NZ,1404
.................... 		count_pulseX++; 
13FC:  INC     08FC
13FE:  BTSC.B  42.1
1400:  INC     08FE
.................... 	} 
1402:  BRA     140A
.................... 	else{ 
.................... 		count_pulseX--; 
1404:  DEC     08FC
1406:  BTSS.B  42.0
1408:  DEC     08FE
.................... 	} 
.................... 	//printf("\r\ncount_pulseX = %d",count_pulseX); 
.................... 	return; 
.................... } 
.................... 	 
140A:  BCLR.B  84.5
140C:  MOV     #1A,W0
140E:  REPEAT  #C
1410:  MOV     [--W15],[W0--]
1412:  MOV     [--W15],W0
1414:  POP     32
1416:  POP     36
1418:  POP     42
141A:  RETFIE  
.................... #INT_IC3 
.................... void Encoder2_A(void){ 
141C:  PUSH    42
141E:  PUSH    36
1420:  PUSH    32
1422:  MOV     W0,[W15++]
1424:  MOV     #2,W0
1426:  REPEAT  #C
1428:  MOV     [W0++],[W15++]
.................... 	ReadPortB = input_b() & 0x000c;  
142A:  MOV     2CA,W5
142C:  AND     W5,#C,W0
142E:  MOV     W0,91E
.................... 	B2 = (ReadPortB & 0x0004) >> 2;  
1430:  MOV     91E,W0
1432:  AND     W0,#4,W5
1434:  MOV     W5,924
1436:  LSR     924
1438:  LSR     924
.................... 	if((B2 ^ B3) == 0){ 
143A:  MOV     924,W0
143C:  XOR     926,W0
143E:  MOV     W0,W5
1440:  CP0     W5
1442:  BRA     NZ,144C
.................... 		count_pulseY--; 
1444:  DEC     0900
1446:  BTSS.B  42.0
1448:  DEC     0902
.................... 	} 
144A:  BRA     1452
.................... 	else{ 
.................... 		count_pulseY++; 
144C:  INC     0900
144E:  BTSC.B  42.1
1450:  INC     0902
.................... 	} 
.................... 	//printf("\r\ncount_pulseY = %d",count_pulseY); 
.................... 	return; 
.................... } 
....................  
1452:  BCLR.B  88.5
1454:  MOV     #1A,W0
1456:  REPEAT  #C
1458:  MOV     [--W15],[W0--]
145A:  MOV     [--W15],W0
145C:  POP     32
145E:  POP     36
1460:  POP     42
1462:  RETFIE  
.................... #INT_IC4 
.................... void Encoder2_B(void){ 
1464:  PUSH    42
1466:  PUSH    36
1468:  PUSH    32
146A:  MOV     W0,[W15++]
146C:  MOV     #2,W0
146E:  REPEAT  #C
1470:  MOV     [W0++],[W15++]
.................... 	ReadPortB = input_b() & 0x000c;   
1472:  MOV     2CA,W5
1474:  AND     W5,#C,W0
1476:  MOV     W0,91E
.................... 	B3 = (ReadPortB & 0x0008) >> 3; 
1478:  MOV     91E,W0
147A:  AND     W0,#8,W5
147C:  MOV     W5,926
147E:  LSR     926
1480:  LSR     926
1482:  LSR     926
.................... 	if((B2 ^ B3) == 0){ 
1484:  MOV     924,W0
1486:  XOR     926,W0
1488:  MOV     W0,W5
148A:  CP0     W5
148C:  BRA     NZ,1496
.................... 		count_pulseY++; 
148E:  INC     0900
1490:  BTSC.B  42.1
1492:  INC     0902
.................... 	} 
1494:  BRA     149C
.................... 	else{ 
.................... 		count_pulseY--; 
1496:  DEC     0900
1498:  BTSS.B  42.0
149A:  DEC     0902
.................... 	} 
.................... 	//printf("\r\ncount_pulseY = %d",count_pulseY); 
.................... 	return; 
.................... } 
....................  
149C:  BCLR.B  88.6
149E:  MOV     #1A,W0
14A0:  REPEAT  #C
14A2:  MOV     [--W15],[W0--]
14A4:  MOV     [--W15],W0
14A6:  POP     32
14A8:  POP     36
14AA:  POP     42
14AC:  RETFIE  
.................... #INT_TIMER4 
.................... void Run_Motor(void){ 
*
20A0:  PUSH    42
20A2:  PUSH    36
20A4:  PUSH    32
20A6:  MOV     W0,[W15++]
20A8:  MOV     #2,W0
20AA:  REPEAT  #C
20AC:  MOV     [W0++],[W15++]
.................... 	disable_interrupts(INT_TIMER5); 
20AE:  BCLR.B  97.4
.................... 	Encoder(); 
20B0:  CALL    18FC
.................... 	if(move_state == 'w'){ 
20B4:  MOV     92E,W4
20B6:  XOR.B   #77,W4L
20B8:  BRA     NZ,214A
.................... 		/* MOVE COMMONLY */  
.................... 		target_posX = 0.5*(DistanceX + DistanceY); 
20BA:  MOV     90C,W0
20BC:  ADD     90E,W0
20BE:  MOV     #0,W1
20C0:  MOV     #0,W2
20C2:  MOV     #0,W3
20C4:  CALL    14AE
20C8:  MOV     W0,W4
20CA:  MOV     W1,W5
20CC:  MOV     W2,W6
20CE:  MOV     W3,W7
20D0:  MOV     #0,W0
20D2:  MOV     #0,W1
20D4:  MOV     #0,W2
20D6:  MOV     #3FE0,W3
20D8:  CALL    1512
20DC:  CALL    1A06
20E0:  MOV     W0,910
.................... 		target_posY = 0.5*(DistanceX - DistanceY); 
20E2:  MOV     90C,W4
20E4:  MOV     90E,W3
20E6:  SUB     W4,W3,W0
20E8:  MOV     #0,W1
20EA:  MOV     #0,W2
20EC:  MOV     #0,W3
20EE:  CALL    14AE
20F2:  MOV     W0,W4
20F4:  MOV     W1,W5
20F6:  MOV     W2,W6
20F8:  MOV     W3,W7
20FA:  MOV     #0,W0
20FC:  MOV     #0,W1
20FE:  MOV     #0,W2
2100:  MOV     #3FE0,W3
2102:  CALL    1512
2106:  CALL    1A06
210A:  MOV     W0,912
.................... 		control_position(MOTOR_L,target_posX,current_posX); 
210C:  MOV     910,W0
210E:  CALL    1A5C
2112:  MOV     W0,W5
2114:  MOV     W1,W6
2116:  MOV     #1,W4
2118:  MOV     W4,B0C
211A:  MOV     W5,B0E
211C:  MOV     W6,B10
211E:  PUSH    916
2120:  POP     B12
2122:  PUSH    918
2124:  POP     B14
2126:  CALL    1D1E
.................... 		control_position(MOTOR_R,target_posY,current_posY); 
212A:  MOV     912,W0
212C:  CALL    1A5C
2130:  MOV     W0,W5
2132:  MOV     W1,W6
2134:  MOV     #2,W4
2136:  MOV     W4,B0C
2138:  MOV     W5,B0E
213A:  MOV     W6,B10
213C:  PUSH    91A
213E:  POP     B12
2140:  PUSH    91C
2142:  POP     B14
2144:  CALL    1D1E
.................... 	} 
2148:  BRA     2200
.................... 	else if(move_state == 's'){ 
214A:  MOV     92E,W4
214C:  XOR.B   #73,W4L
214E:  BRA     NZ,2172
.................... 		/* Backward a little bit */ 
.................... 		drive_motor(MOTOR_L,CCW,100); 
2150:  MOV     #1,W4
2152:  MOV     W4,B52
2154:  MOV     #2,W4
2156:  MOV     W4,B54
2158:  MOV     #64,W4
215A:  MOV     W4,B56
215C:  CALL    11FC
.................... 		drive_motor(MOTOR_R,CW,100); 
2160:  MOV     #2,W4
2162:  MOV     W4,B52
2164:  MOV     #1,W4
2166:  MOV     W4,B54
2168:  MOV     #64,W4
216A:  MOV     W4,B56
216C:  CALL    11FC
.................... 	} 
2170:  BRA     2200
.................... 	else if(move_state == '1'){ 
2172:  MOV     92E,W4
2174:  XOR.B   #31,W4L
2176:  BRA     NZ,21A2
.................... 		/*To RED & ORANGE pen position*/ 
.................... 		control_position(MOTOR_L,RED_X,current_posX); 
2178:  MOV     #1,W4
217A:  MOV     W4,B0C
217C:  CLR     B0E
217E:  CLR     B10
2180:  PUSH    916
2182:  POP     B12
2184:  PUSH    918
2186:  POP     B14
2188:  CALL    1D1E
.................... 		control_position(MOTOR_R,RED_Y,current_posY); 
218C:  MOV     #2,W4
218E:  MOV     W4,B0C
2190:  CLR     B0E
2192:  CLR     B10
2194:  PUSH    91A
2196:  POP     B12
2198:  PUSH    91C
219A:  POP     B14
219C:  CALL    1D1E
.................... 	} 
21A0:  BRA     2200
.................... 	else if(move_state == '2'){ 
21A2:  MOV     92E,W4
21A4:  XOR.B   #32,W4L
21A6:  BRA     NZ,21D2
.................... 		/*To GREEN pen position*/ 
.................... 		control_position(MOTOR_L,GREEN_X,current_posX); 
21A8:  MOV     #1,W4
21AA:  MOV     W4,B0C
21AC:  CLR     B0E
21AE:  CLR     B10
21B0:  PUSH    916
21B2:  POP     B12
21B4:  PUSH    918
21B6:  POP     B14
21B8:  CALL    1D1E
.................... 		control_position(MOTOR_R,GREEN_Y,current_posY); 
21BC:  MOV     #2,W4
21BE:  MOV     W4,B0C
21C0:  CLR     B0E
21C2:  CLR     B10
21C4:  PUSH    91A
21C6:  POP     B12
21C8:  PUSH    91C
21CA:  POP     B14
21CC:  CALL    1D1E
.................... 	} 
21D0:  BRA     2200
.................... 	else if(move_state == '3'){ 
21D2:  MOV     92E,W4
21D4:  XOR.B   #33,W4L
21D6:  BRA     NZ,2200
.................... 		/*To BLUE & BLACK pen position*/ 
.................... 		control_position(MOTOR_L,BLUE_X,current_posX); 
21D8:  MOV     #1,W4
21DA:  MOV     W4,B0C
21DC:  CLR     B0E
21DE:  CLR     B10
21E0:  PUSH    916
21E2:  POP     B12
21E4:  PUSH    918
21E6:  POP     B14
21E8:  CALL    1D1E
.................... 		control_position(MOTOR_R,BLUE_Y,current_posY); 
21EC:  MOV     #2,W4
21EE:  MOV     W4,B0C
21F0:  CLR     B0E
21F2:  CLR     B10
21F4:  PUSH    91A
21F6:  POP     B12
21F8:  PUSH    91C
21FA:  POP     B14
21FC:  CALL    1D1E
.................... 	} 
.................... 	return; 
.................... } 
....................  
2200:  BCLR.B  87.3
2202:  MOV     #1A,W0
2204:  REPEAT  #C
2206:  MOV     [--W15],[W0--]
2208:  MOV     [--W15],W0
220A:  POP     32
220C:  POP     36
220E:  POP     42
2210:  RETFIE  
.................... #INT_TIMER5 
.................... void Run_Motor2(void){ 
2212:  PUSH    42
2214:  PUSH    36
2216:  PUSH    32
2218:  MOV     W0,[W15++]
221A:  MOV     #2,W0
221C:  REPEAT  #C
221E:  MOV     [W0++],[W15++]
.................... 	disable_interrupts(INT_TIMER4); 
2220:  BCLR.B  97.3
.................... 	return; 
2222:  BCLR.B  87.4
2224:  MOV     #1A,W0
2226:  REPEAT  #C
2228:  MOV     [--W15],[W0--]
222A:  MOV     [--W15],W0
222C:  POP     32
222E:  POP     36
2230:  POP     42
2232:  RETFIE  
.................... } 
....................  
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                                 EOF                                    **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #import(file="EVENT_DRIVEN_CCS.o") 
.................... /* 
.................... *************************** C SOURCE FILE ************************************ 
....................  
.................... project   : 
.................... filename  : EVENT_DRIVEN_CCS.C 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #define EVENT_DRIVEN_CCS_C_SRC 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             MODULES USED                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #include "EVENT_DRIVEN_CCS.h" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : EVENT_DRIVEN_CCS.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  EVENT_DRIVEN_CCS_INCLUDED 
.................... #define  EVENT_DRIVEN_CCS_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
.................... #include "CONFIG_PIC24.H" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : CONFIG_PIC24.H 
.................... version   :  
.................... date      : 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  CONFIG_PIC24_INCLUDED 
.................... #define  CONFIG_PIC24_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
.................... #include <24FJ48GA002.H> 
.................... //////////// Standard Header file for the PIC24FJ48GA002 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC24FJ48GA002 
....................  
.................... #list 
....................  
.................... //#include <24FJ16GA002.H> 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #DEVICE ADC=10 
.................... #fuses NOIOL1WAY, NODEBUG, NOWRT, NOPROTECT, NOJTAG, NOWDT 
.................... #fuses OSCIO 
.................... #fuses FRC_PLL 
.................... #case 
.................... #type signed 
.................... #use delay(internal=8 MHz, clock = 32000000)  
.................... #use fast_io(ALL) 
.................... #pin_select U1TX = PIN_B13 
.................... #pin_select U1RX = PIN_B12 
.................... #use RS232 (UART1, BAUD = 115200, XMIT = PIN_B13, RCV = PIN_B12, STREAM = COM_A) 
.................... #BIT TX1IF = 0x0084.12  // Tx1 Interrupt flag  IFS0.12 
....................  
.................... ////////////////////////////////////////////////// 
.................... // EXT INT pins 
.................... #if 1 
.................... // INT0 is RB7 
.................... #pin_select INT1 = PIN_B5  //Limit Switch1 
.................... #pin_select INT2 = PIN_B4  //Limit Switch2 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... #if 0 
....................  
.................... #pin_select U2TX = PIN_B10 
.................... #pin_select U2RX = PIN_B11 
....................  
.................... //#use RS232 (UART2, BAUD = 9600, XMIT = PIN_B9, RCV = PIN_B8, STREAM = COM_B) 
.................... //#use RS232 (BAUD = 9600, XMIT = PIN_B10, RCV = PIN_B11, STREAM = COM_B) 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
.................... // REMAP i/o pins 
.................... #if 1 
.................... #pin_select OC1 = PIN_B6   //ENA1 
.................... #pin_select OC2 = PIN_B7   //ENA2 
.................... #pin_select IC1 = PIN_B0   //Encoder1_A 
.................... #pin_select IC2 = PIN_B1   //Encoder1_B 
.................... #pin_select IC3 = PIN_B2   //Encoder2_A 
.................... #pin_select IC4 = PIN_B3   //B3 = Encoder2_B 
....................  
.................... #endif 
.................... ////////////////////////////////////////////////// 
....................  
.................... #include <stdlib.h>   
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
.................... #USE DYNAMIC_MEMORY 
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu\r\n", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................  
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                    
....................  
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "BL_support.h" 
.................... /******************************************************************************/ 
.................... /* File:    BL_Support.h													  */ 
.................... /* Author:  Dr.Santi Nuratch												  */ 
.................... /*          Embedded Computing and Control Lab., INC-KMUTT 				      */ 
.................... /* Created on 22 September 2016, 13:14										  */ 
.................... /******************************************************************************/ 
....................  
.................... #ifndef BL_SUPPORT_H 
.................... #define	BL_SUPPORT_H 
....................  
.................... /******************************************************************************/ 
.................... /*                   BOOTLOADER SUPPORT CONFIGURATION                         */ 
.................... /*                          (DO NOT CHANGE)                                   */ 
.................... /******************************************************************************/ 
.................... /* Bootloader */ 
.................... #define LOADER_PAGES 	3  
.................... #define ERASE_SIZE 		2048    /* 2048 bytes, 24-bit (3 bytes) per instruction, but it uses 4 bytes aligned --> 4 bytes per word */ 
....................                                 /* each block has 512 instructions (1024 words), each instruction requires 4 bytes (2 words), so 512*4 = 2048 bytes */ 
.................... #define LOADER_SIZE 	((LOADER_PAGES * (ERASE_SIZE/2)) - 1)   /* 2 bytes per address, so divided by 2, 2048/2 = 1024 */  
.................... #define LOADER_END  	LOADER_SIZE                             /* End address      */ 
.................... #define LOADER_ADDR 	0xC00//(LOADER_END - LOADER_SIZE)       /* Start address    */ 
....................  
.................... #build (reset=LOADER_END+1, interrupt=LOADER_END+5) 
.................... #org 0, LOADER_END {}   /* 0x0000 - END */ 
....................  
.................... /******************************************************************************/ 
.................... /*                                  END                                       */ 
.................... /******************************************************************************/ 
....................  
.................... #endif	/* BL_SUPPORT_H */ 
....................  
....................  
.................... /****************************************************************************/ 
.................... // o/p pins  LED 
.................... #define  IN1  PIN_A0 
.................... #define  IN2  PIN_A1   
.................... #define  IN3  PIN_A2   
.................... #define  IN4  PIN_A4   
....................  
.................... // i/p pins  PBSW 
.................... #define  SW0  PIN_B1   //Encoder1B 
.................... #define  SW1  PIN_B3   //Encoder2B 
.................... #define  SW2  PIN_B6 
.................... #define  SW3  PIN_B7 
....................  
.................... // ADC  or  i/o pins if not use ADC 
.................... #define  AX0  PIN_A0 
.................... #define  AX1  PIN_A1 
.................... #define  AX2  PIN_B0  // RP0 remap pin 
.................... #define  AX3  PIN_B1  // RP1 remap pin 
....................  
.................... /****************************************************************************/ 
....................  
.................... #endif 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
....................  
....................  
.................... #include "CDATPIC24.H" 
.................... /* 
.................... ***************************   C DATA TYPE   ******************************* 
.................... **                                                                              
.................... **  project     : C Data Types Extension                                                 
.................... **  filename  : CDATPIC24.H                                                                 
.................... **                                                                                                                
.................... *************************************************************************** 
.................... */ 
....................  
.................... #ifndef   CDATPIC24_INCLUDED 
.................... #define   CDATPIC24_INCLUDED 
....................  
.................... /* 
.................... *************************************************************************** 
....................                             C  TYPEDEFS                                            
.................... *************************************************************************** 
.................... */ 
....................  
.................... /**** C type extensions ****/ 
.................... typedef unsigned char      int8u; 
.................... typedef signed   char      int8s; 
.................... typedef unsigned int       int16u; 
.................... typedef signed   int       int16s; 
.................... typedef unsigned long      int32u; 
.................... typedef signed   long      int32s; 
.................... typedef unsigned long long int64u; 
.................... typedef signed   long long int64s; 
....................  
....................  
.................... #endif 
.................... /* 
.................... ************************************************************************** 
....................                                EOF                                                    
.................... /************************************************************************* 
.................... */ 
....................  
....................  
.................... #include "EVENT_TYPE_CCS.H" 
.................... /* 
.................... *************************** C HEADER FILE ************************************ 
....................  
.................... project   : 
.................... filename  : EVENT_TYPE_CCS.H 
.................... version   : 2 
.................... date      : 
....................  
.................... ****************************************************************************** 
....................  
.................... Copyright (c) 20xx , 
.................... All rights reserved. 
....................  
.................... ****************************************************************************** 
....................  
.................... VERSION HISTORY: 
.................... ---------------------------- 
.................... Version      : 1 
.................... Date         : 
.................... Revised by   : 
.................... Description  : 
....................  
.................... Version      : 2 
.................... Date         : 
.................... Revised by   : 
.................... Description  : * 
....................                * 
....................                * 
....................  
.................... ****************************************************************************** 
.................... */ 
....................  
.................... #ifndef  EVENT_TYPE_CCS_INCLUDED 
.................... #define  EVENT_TYPE_CCS_INCLUDED 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              MODULES USED                              **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //#include <stdlib.h>  // depend on application requirements. 
.................... //#include "cdat68k.h"  // define data types 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... typedef enum 
.................... { 
....................     EV_NULL, 
....................     EV_TIMER1, 
....................     EV_TIMER2, 
....................     EV_TIMER3, 
....................     EV_STMR0, 
....................     EV_STMR1, 
....................     EV_STMR2, 
....................     EV_STMR3, 
....................     EV_STMR4, 
....................     EV_SW0, 
....................     EV_SW1, 
....................     EV_SW2, 
....................     EV_SW3, 
....................     EV_TBE1, 
....................     EV_RDA1, 
....................     EV_OC1, 
....................     EV_OC2, 
....................     EV_IC1, 
....................     EV_IC2, 
....................     EV_EXT0, 
....................     EV_EXT1, 
....................     EV_EXT2 
.................... } EV_TYPE; 
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #ifndef EVENT_TYPE_CCS_C_SRC 
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /***********    Macro for Declare and Define Memory Blocks ******************/ 
....................  
.................... #define DECLARE_MEM(BLOCK_TYPE_DEF, MEM_ARRAY, STRUCT_Q_ARRAY, N_BLOCK); \ 
.................... PTR_STRUCT STRUCT_Q_ARRAY[N_BLOCK]; \ 
.................... BLOCK_TYPE_DEF MEM_ARRAY[N_BLOCK]; 
....................  
.................... /****************************************************************************/ 
....................  
.................... // Queue error codes 
.................... #define Q_OK 0 
.................... #define Q_FULL 1 
.................... #define Q_EMPLY 2 
....................  
.................... //timer mode 
.................... #define SINGLE 0 
.................... #define REPEAT 1 
....................  
.................... //timer enable, disable 
.................... #define ON 1 
.................... #define OFF 0 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... //Data type for Tick Counter 
.................... typedef volatile int32u tickType; 
....................  
.................... //Event Structure 
.................... typedef volatile struct 
.................... { 
....................     EV_TYPE evType; 
....................     void *evDataPtr; 
.................... } EV_STRUCT; 
....................  
.................... //Event Queue Structure 
.................... typedef volatile struct 
.................... { 
....................     int8u evQLength; 
....................     int8u evQCount; 
....................     int8u evQPut; 
....................     int8u evQGet; 
....................     EV_STRUCT *evQArray; 
.................... } EVQ_STRUCT; 
....................  
.................... //Event Queue function error codes 
.................... typedef enum 
.................... { 
....................     EVQ_OK, 
....................     EVQ_FULL, 
....................     EVQ_EMPTY 
.................... } Q_ERR; 
....................  
.................... //Structure of pointer for memm queue array 
.................... typedef volatile struct voidPtrStrict 
.................... { 
....................     void *blockPtr; 
.................... } PTR_STRUCT; 
....................  
.................... //Structure type for Mem Control Block 
.................... typedef volatile struct memControlStruct 
.................... { 
....................     void *memPtr; 
....................     int16u qArrayLength; 
....................     int16u count; 
....................     int16u put; 
....................     int16u get; 
....................     PTR_STRUCT *qArrayPtr; // Pointer to array of pointer to void 
.................... } MCB_STRUCT; 
....................  
.................... //Structure type for queue of pointer 
.................... typedef volatile struct qPtrXStruct 
.................... { 
....................     int16u arrayLength; 
....................     int16u count; 
....................     int16u put; 
....................     int16u get; 
....................     PTR_STRUCT *arrayPtr; // Pointer to array of pointer to void 
.................... } QPTRX_STRUCT; 
....................  
.................... //Structure type for queue of int8u 
.................... typedef volatile struct q8UStruct 
.................... { 
....................     int16u arrayLength; 
....................     int16u count; 
....................     int16u put; 
....................     int16u get; 
....................     int8u *arrayPtr; // Pointer to array of int8u 
.................... } Q8UX_STRUCT; 
....................  
.................... //STimer struct 
.................... typedef volatile struct 
.................... { 
....................     int8u tmrEnb; //enable (ON) / disable (OFF) software timer 
....................     int8u tmrMode; //operating mode: SINGLE / REPEAT 
....................     tickType tmrInit; // Initial value of tick count 
....................     tickType tmrCount; //Down Counter value 
....................     EVQ_STRUCT *evQPtr; // Pointer to Event Queue 
....................     EV_STRUCT sTmrEvStruct; //software Timer Event Structure 
.................... } STMR_STRUCT; 
....................  
.................... //RX Frame State 
.................... typedef volatile enum 
.................... { 
....................     FRAME_WAIT, 
....................     FRAME_PROGRESS 
.................... } FRAME_STATE;  
....................  
.................... //Tx state 
.................... typedef volatile enum 
.................... { 
....................     TX1_BUSY, 
....................     TX1_READY 
.................... } TX1_STATUS; 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                         EXPORTED VARIABLES                             **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... #ifndef EVENT_DRIVEN_CCS_C_SRC 
....................  
.................... extern volatile int16u EvQFullCount; 
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                       EXPORTED FUNCTIONS                               **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                          Library Functions                               // 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /*************************  Event Queue Functions  **************************/ 
.................... /****************************************************************************/ 
....................  
.................... void EvSructInit (EV_STRUCT *evStruct , EV_TYPE evType, void *evDataPtr ); 
....................  
.................... void EvQInit (EVQ_STRUCT *evQ, EV_STRUCT *evArray, int8u qL ); 
....................  
.................... void EvQPut (EVQ_STRUCT *evQ, EV_STRUCT evSource, Q_ERR *errPtr); 
....................  
.................... void EvQGet (EVQ_STRUCT *evQ, EV_STRUCT *evDest, Q_ERR *errPtr); 
....................  
.................... int16u EvQCount (EVQ_STRUCT *evQ); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /****************************  Memory Functions  ****************************/ 
.................... /****************************************************************************/ 
....................  
.................... void MemStructArrayInit (void *memArrayPtr, int16u blockByteSize, int16u nBlock, 
....................                          PTR_STRUCT *memQArrayPtr, MCB_STRUCT *memQcbPtr); 
....................  
.................... void MemPtrPut (MCB_STRUCT *memQcbPtr, void *memBlockPtr, int8u *errPtr); 
....................  
.................... void MemPtrGet (MCB_STRUCT *memQcbPtr, PTR_STRUCT *destStructPtr, int8u *errPtr); 
....................  
.................... int16u MemQReadyCount (MCB_STRUCT *memQcbPtr); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /***************************** QPTRX Functions  *****************************/ 
.................... /****************************************************************************/ 
....................  
.................... void QPtrXInit (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *buffPtr, int16u qL); 
....................  
.................... void QPtrXPut (QPTRX_STRUCT *qStructPtr, PTR_STRUCT ptrStruct, int8u *errPtr); 
....................  
.................... void QPtrXGet (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *destPtr, int8u *errPtr); 
....................  
.................... int16u QPtrXCount (QPTRX_STRUCT *qStructPtr); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /***************************** Q8UX Functions *******************************/ 
.................... /****************************************************************************/ 
....................  
.................... void Q8UXInit (Q8UX_STRUCT *qStructPtr, int8u *buffPtr, int16u qL); 
....................  
.................... void Q8UXPut (Q8UX_STRUCT *qStructPtr, int8u dataSource, int8u *errPtr); 
....................  
.................... void Q8UXGet (Q8UX_STRUCT *qStructPtr, int8u *destPtr, int8u *errPtr); 
....................  
.................... int16u Q8UXCount (Q8UX_STRUCT *qStructPtr); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /************************ Software Timer Functions  *************************/ 
.................... /****************************************************************************/ 
....................  
.................... void SoftwareTimer (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr); 
....................  
.................... void STmrSystemDeInit (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr); 
....................  
.................... void STmrInit (STMR_STRUCT *sTmrPtr, int8u z, tickType, initValue, int8u mode, 
....................                EV_TYPE evType, void *evDataPtr, EVQ_STRUCT *evQPtr); 
....................  
.................... void STmrStart (STMR_STRUCT *sTmrPtr, int8u z); 
....................  
.................... void StmrPause (STMR_STRUCT *sTmrPtr, int8u z); 
....................  
.................... void STmrStop (STMR_STRUCT *sTmrPtr, int8u z); 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                           CPU Dependent Functions   
.................... /****************************************************************************/ 
....................  
.................... void DisableIntr (void); 
....................  
.................... void EnableIntr (void); 
....................  
.................... void CpuIdle (void); 
....................  
....................  
.................... /****************************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                              EOF                                       **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        DEFINITIONS AND MACROS                          **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                        TYPEDEFS AND STRUCTURES                         **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                      PROTOTYPES OF LOCAL FUNCTIONS                     **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED VARIABLES                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
.................... volatile int16u EvQFullCount =0; 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                            GLOBAL VARIABLES                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                           EXPORTED FUNCTIONS                           **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
.................... //                          Library Functions                               // 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /*************************  Event Queue Functions  **************************/ 
.................... /****************************************************************************/ 
....................  
.................... void EvSructInit (EV_STRUCT *evStruct , EV_TYPE evType, void *evDataPtr ) 
.................... { 
....................     evStruct->evType = evType; 
....................     evStruct->evDataPtr = evDataPtr; 
....................     return; 
.................... } 
....................  
.................... void EvQInit (EVQ_STRUCT *evQ, EV_STRUCT *evArray, int8u qL ) 
.................... { 
....................     evQ->evQLength = qL; 
....................     evQ->evQCount = 0; 
....................     evQ->evQPut = 0; 
....................     evQ->evQGet = 0; 
....................     evQ->evQArray = evArray; 
.................... } 
....................  
.................... void EvQPut (EVQ_STRUCT *evQ,EV_STRUCT evSource, Q_ERR *errPtr) 
.................... { 
....................     if (evQ->evQCount == evQ->evQLength) 
....................     { 
....................         *errPtr = EVQ_FULL; 
....................     } 
....................     else 
....................     { 
....................         evQ->evQCount++; 
....................         evQ->evQArray[evQ->evQPut] = evSource; 
....................         evQ->evQPut++; 
....................         if (evQ->evQPut == evQ->evQLength) 
....................         { 
....................             evQ->evQPut = 0; 
....................         } 
....................         *errPtr = EVQ_OK; 
....................     } 
....................     return; 
.................... } 
....................  
.................... void EvQGet (EVQ_STRUCT *evQ, EV_STRUCT *evDest, Q_ERR *errPtr) 
.................... { 
....................     EV_STRUCT tempEvDest; 
....................     if (evQ->evQCount == 0) 
....................     { 
....................         *errPtr = EVQ_EMPTY; 
....................     } 
....................     else  
....................     { 
....................         evQ->evQCount--; 
....................         tempEvDest = evQ->evQArray[evQ->evQGet]; 
....................         *evDest = tempEvDest; 
....................         evQ->evQGet++; 
....................         if (evQ->evQGet == evQ->evQLength) 
....................         { 
....................             evQ->evQGet = 0; 
....................         } 
....................         *errPtr = EVQ_OK; 
....................     } 
....................     return; 
.................... } 
....................  
.................... int16u EvQCount (EVQ_STRUCT *evQ) 
.................... { 
....................     return evQ->evQCount; 
.................... } 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /****************************  Memory Functions  ****************************/ 
.................... /****************************************************************************/ 
....................  
.................... void MemStructArrayInit (void *memArrayPtr, int16u blockByteSize, int16u nBlock, 
....................     PTR_STRUCT *memQArrayPtr, MCB_STRUCT *memQcbPtr) 
.................... { 
....................     int16u i; 
....................     for( i=0;i<nBlock;i++) 
....................     { 
....................         memQArrayPtr[i].blockPtr = (void *)((int8u *)memArrayPtr + (blockByteSize * i)); 
....................     } 
....................     memQcbPtr->memPtr = memArrayPtr; 
....................     memQcbPtr->qArrayLength = nBlock; 
....................     memQcbPtr->count = nBlock; 
....................     memQcbPtr->put = 0; 
....................     memQcbPtr->get = 0; 
....................     memQcbPtr->qArrayPtr = memQArrayPtr; 
....................     return;  
.................... } 
....................  
.................... void MemPtrPut (MCB_STRUCT *memQcbPtr, void *memBlockPtr, int8u *errPtr) 
.................... { 
....................     if (memQcbPtr->count == memQcbPtr->qArrayLength) 
....................     { 
....................         *errPtr = Q_FULL; 
....................     } 
....................     else 
....................     { 
....................         memQcbPtr->count++; 
....................         memQcbPtr->qArrayPtr[memQcbPtr->put].blockPtr = memBlockPtr; 
....................         memQcbPtr->put++; 
....................         if (memQcbPtr->put == memQcbPtr->qArrayLength) 
....................         { 
....................             memQcbPtr->put = 0; 
....................         } 
....................         *errPtr = Q_OK; 
....................     } 
....................     return; 
....................      
.................... } 
.................... void MemPtrGet (MCB_STRUCT *memQcbPtr, PTR_STRUCT *destStructPtr, int8u *errPtr) 
.................... { 
....................     if (memQcbPtr->count ==0) 
....................     { 
....................         destStructPtr->blockPtr = (void *)NULL; 
....................         *errPtr = Q_EMPLY; 
....................     } 
....................     else 
....................     { 
....................         memQcbPtr->count--; 
....................         destStructPtr->blockPtr = memQcbPtr->qArrayPtr[memQcbPtr->get].blockPtr; 
....................         memQcbPtr->get++; 
....................         if (memQcbPtr->get == memQcbPtr->qArrayLength) 
....................         { 
....................             memQcbPtr->get = 0; 
....................         } 
....................     } 
....................     return; 
.................... } 
.................... int16u MemQReadyCount (MCB_STRUCT *memQcbPtr) 
.................... { 
....................     return memQcbPtr->count; 
.................... } 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /***************************** QPTRX Functions  *****************************/ 
.................... /****************************************************************************/ 
....................  
.................... void QPtrXInit (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *buffPtr, int16u qL) 
*
2336:  MOV     W5,[W15++]
.................... { 
....................         qStructPtr->arrayLength = qL; 
2338:  MOV     #0,W0
233A:  ADD     ABE,W0
233C:  MOV     W0,W5
233E:  MOV     AC2,W4
2340:  MOV     W4,[W5+#0]
....................         qStructPtr->count = 0; 
2342:  MOV     #2,W0
2344:  ADD     ABE,W0
2346:  MOV     W0,W5
2348:  CLR.B   [W5]
234A:  MOV.B   #0,W0L
234C:  MOV.B   W0L,[W5+#1]
....................         qStructPtr->put = 0; 
234E:  MOV     #4,W0
2350:  ADD     ABE,W0
2352:  MOV     W0,W5
2354:  CLR.B   [W5]
2356:  MOV.B   #0,W0L
2358:  MOV.B   W0L,[W5+#1]
....................         qStructPtr->get = 0; 
235A:  MOV     #6,W0
235C:  ADD     ABE,W0
235E:  MOV     W0,W5
2360:  CLR.B   [W5]
2362:  MOV.B   #0,W0L
2364:  MOV.B   W0L,[W5+#1]
....................         qStructPtr->arrayPtr = buffPtr; 
2366:  MOV     #8,W0
2368:  ADD     ABE,W0
236A:  MOV     W0,W5
236C:  MOV     AC0,W4
236E:  MOV     W4,[W5+#0]
....................         return; 
2370:  MOV     [--W15],W5
2372:  RETURN  
.................... } 
.................... void QPtrXPut (QPTRX_STRUCT *qStructPtr, PTR_STRUCT ptrStruct, int8u *errPtr) 
*
0E2C:  MOV     W5,[W15++]
0E2E:  MOV     W6,[W15++]
.................... { 
....................     if (qStructPtr->count == qStructPtr->arrayLength) 
0E30:  MOV     #2,W0
0E32:  ADD     B02,W0
0E34:  MOV     [W0],W5
0E36:  MOV     #0,W0
0E38:  ADD     B02,W0
0E3A:  MOV     W0,W4
0E3C:  MOV     [W4],W0
0E3E:  CP      W5,W0
0E40:  BRA     NZ,E4A
....................     { 
....................         *errPtr = Q_FULL; 
0E42:  MOV     B06,W5
0E44:  MOV.B   #1,W0L
0E46:  MOV.B   W0L,[W5]
....................     } 
0E48:  BRA     E90
....................     else 
....................     { 
....................         qStructPtr->count++; 
0E4A:  MOV     #2,W0
0E4C:  ADD     B02,W0
0E4E:  MOV     W0,W5
0E50:  INC     [W5],[W5]
....................         qStructPtr->arrayPtr[qStructPtr->put] = ptrStruct; 
0E52:  MOV     #8,W0
0E54:  ADD     B02,W0
0E56:  MOV     [W0],W5
0E58:  MOV     #4,W0
0E5A:  ADD     B02,W0
0E5C:  MOV     [W0],W6
0E5E:  SL      W6,#1,W0
0E60:  ADD     W0,W5,W6
0E62:  MOV     B04,W4
0E64:  MOV     W4,[W6+#0]
....................         qStructPtr->put++; 
0E66:  MOV     #4,W0
0E68:  ADD     B02,W0
0E6A:  MOV     W0,W5
0E6C:  INC     [W5],[W5]
....................         if (qStructPtr->put == qStructPtr->arrayLength) 
0E6E:  MOV     #4,W0
0E70:  ADD     B02,W0
0E72:  MOV     [W0],W5
0E74:  MOV     #0,W0
0E76:  ADD     B02,W0
0E78:  MOV     W0,W4
0E7A:  MOV     [W4],W0
0E7C:  CP      W5,W0
0E7E:  BRA     NZ,E8C
....................         { 
....................             qStructPtr->put = 0; 
0E80:  MOV     #4,W0
0E82:  ADD     B02,W0
0E84:  MOV     W0,W5
0E86:  CLR.B   [W5]
0E88:  MOV.B   #0,W0L
0E8A:  MOV.B   W0L,[W5+#1]
....................         } 
....................         *errPtr = Q_OK; 
0E8C:  MOV     B06,W5
0E8E:  CLR.B   [W5]
....................     } 
....................     return; 
0E90:  MOV     [--W15],W6
0E92:  MOV     [--W15],W5
0E94:  RETURN  
.................... } 
.................... void QPtrXGet (QPTRX_STRUCT *qStructPtr, PTR_STRUCT *destPtr, int8u *errPtr) 
*
23DC:  MOV     W5,[W15++]
23DE:  MOV     W6,[W15++]
23E0:  MOV     W7,[W15++]
.................... { 
....................     if (qStructPtr->count == 0) 
23E2:  MOV     #2,W0
23E4:  ADD     ABE,W0
23E6:  MOV     [W0],W5
23E8:  CP0     W5
23EA:  BRA     NZ,23F4
....................     { 
....................         *errPtr = Q_EMPLY; 
23EC:  MOV     AC2,W5
23EE:  MOV.B   #2,W0L
23F0:  MOV.B   W0L,[W5]
....................     } 
23F2:  BRA     243E
....................     else 
....................     { 
....................         qStructPtr->count--; 
23F4:  MOV     #2,W0
23F6:  ADD     ABE,W0
23F8:  MOV     W0,W5
23FA:  DEC     [W5],[W5]
....................         destPtr->blockPtr = qStructPtr->arrayPtr[qStructPtr->get].blockPtr; 
23FC:  MOV     #0,W0
23FE:  ADD     AC0,W0
2400:  MOV     W0,W5
2402:  MOV     #8,W0
2404:  ADD     ABE,W0
2406:  MOV     [W0],W6
2408:  MOV     #6,W0
240A:  ADD     ABE,W0
240C:  MOV     [W0],W7
240E:  SL      W7,#1,W7
2410:  ADD     W6,W7,W0
2412:  MOV     [W0],[W5]
....................         qStructPtr->get++; 
2414:  MOV     #6,W0
2416:  ADD     ABE,W0
2418:  MOV     W0,W5
241A:  INC     [W5],[W5]
....................         if (qStructPtr->get == qStructPtr->arrayLength) 
241C:  MOV     #6,W0
241E:  ADD     ABE,W0
2420:  MOV     [W0],W5
2422:  MOV     #0,W0
2424:  ADD     ABE,W0
2426:  MOV     W0,W4
2428:  MOV     [W4],W0
242A:  CP      W5,W0
242C:  BRA     NZ,243A
....................         { 
....................             qStructPtr->get = 0; 
242E:  MOV     #6,W0
2430:  ADD     ABE,W0
2432:  MOV     W0,W5
2434:  CLR.B   [W5]
2436:  MOV.B   #0,W0L
2438:  MOV.B   W0L,[W5+#1]
....................         } 
....................         *errPtr = Q_OK; 
243A:  MOV     AC2,W5
243C:  CLR.B   [W5]
....................     } 
....................     return; 
243E:  MOV     [--W15],W7
2440:  MOV     [--W15],W6
2442:  MOV     [--W15],W5
2444:  RETURN  
.................... } 
.................... int16u QPtrXCount (QPTRX_STRUCT *qStructPtr) 
.................... { 
....................     return qStructPtr->count; 
.................... } 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /***************************** Q8UX Functions *******************************/ 
.................... /****************************************************************************/ 
....................  
.................... void Q8UXInit (Q8UX_STRUCT *qStructPtr, int8u *buffPtr, int16u qL) 
*
2374:  MOV     W5,[W15++]
.................... { 
....................     qStructPtr->arrayLength = qL; 
2376:  MOV     #0,W0
2378:  ADD     ABE,W0
237A:  MOV     W0,W5
237C:  MOV     AC2,W4
237E:  MOV     W4,[W5+#0]
....................     qStructPtr->count = 0; 
2380:  MOV     #2,W0
2382:  ADD     ABE,W0
2384:  MOV     W0,W5
2386:  CLR.B   [W5]
2388:  MOV.B   #0,W0L
238A:  MOV.B   W0L,[W5+#1]
....................     qStructPtr->put = 0; 
238C:  MOV     #4,W0
238E:  ADD     ABE,W0
2390:  MOV     W0,W5
2392:  CLR.B   [W5]
2394:  MOV.B   #0,W0L
2396:  MOV.B   W0L,[W5+#1]
....................     qStructPtr->get = 0; 
2398:  MOV     #6,W0
239A:  ADD     ABE,W0
239C:  MOV     W0,W5
239E:  CLR.B   [W5]
23A0:  MOV.B   #0,W0L
23A2:  MOV.B   W0L,[W5+#1]
....................     qStructPtr->arrayPtr = buffPtr; 
23A4:  MOV     #8,W0
23A6:  ADD     ABE,W0
23A8:  MOV     W0,W5
23AA:  MOV     AC0,W4
23AC:  MOV     W4,[W5+#0]
....................     return; 
23AE:  MOV     [--W15],W5
23B0:  RETURN  
.................... } 
.................... void Q8UXPut (Q8UX_STRUCT *qStructPtr, int8u dataSource, int8u *errPtr) 
.................... { 
....................     if (qStructPtr->count == qStructPtr->arrayLength) 
....................     { 
....................         *errPtr = Q_FULL; 
....................     } 
....................     else 
....................     { 
....................         qStructPtr->count++; 
....................         qStructPtr->arrayPtr[qStructPtr->put] = dataSource; 
....................         qStructPtr->put++; 
....................         if (qStructPtr->put == qStructPtr->arrayLength) 
....................         { 
....................             qStructPtr->put = 0; 
....................         } 
....................         *errPtr = Q_OK; 
....................     } 
....................     return; 
.................... } 
.................... void Q8UXGet (Q8UX_STRUCT *qStructPtr, int8u *destPtr, int8u *errPtr) 
*
1154:  MOV     W5,[W15++]
1156:  MOV     W6,[W15++]
1158:  MOV     W7,[W15++]
.................... { 
....................     if (qStructPtr->count == 0) 
115A:  MOV     #2,W0
115C:  ADD     AF8,W0
115E:  MOV     [W0],W5
1160:  CP0     W5
1162:  BRA     NZ,116C
....................     { 
....................         *errPtr = Q_EMPLY; 
1164:  MOV     AFC,W5
1166:  MOV.B   #2,W0L
1168:  MOV.B   W0L,[W5]
....................     } 
116A:  BRA     11B0
....................     else 
....................     { 
....................         qStructPtr->count--; 
116C:  MOV     #2,W0
116E:  ADD     AF8,W0
1170:  MOV     W0,W5
1172:  DEC     [W5],[W5]
....................         *destPtr = qStructPtr->arrayPtr[qStructPtr->get]; 
1174:  MOV     AFA,W5
1176:  MOV     #8,W0
1178:  ADD     AF8,W0
117A:  MOV     [W0],W6
117C:  MOV     #6,W0
117E:  ADD     AF8,W0
1180:  MOV     [W0],W7
1182:  ADD     W6,W7,W0
1184:  MOV.B   [W0],[W5]
....................         qStructPtr->get++; 
1186:  MOV     #6,W0
1188:  ADD     AF8,W0
118A:  MOV     W0,W5
118C:  INC     [W5],[W5]
....................         if (qStructPtr->get == qStructPtr->arrayLength) 
118E:  MOV     #6,W0
1190:  ADD     AF8,W0
1192:  MOV     [W0],W5
1194:  MOV     #0,W0
1196:  ADD     AF8,W0
1198:  MOV     W0,W4
119A:  MOV     [W4],W0
119C:  CP      W5,W0
119E:  BRA     NZ,11AC
....................         { 
....................             qStructPtr->get = 0; 
11A0:  MOV     #6,W0
11A2:  ADD     AF8,W0
11A4:  MOV     W0,W5
11A6:  CLR.B   [W5]
11A8:  MOV.B   #0,W0L
11AA:  MOV.B   W0L,[W5+#1]
....................         } 
....................         *errPtr = Q_OK; 
11AC:  MOV     AFC,W5
11AE:  CLR.B   [W5]
....................     } 
....................     return; 
11B0:  MOV     [--W15],W7
11B2:  MOV     [--W15],W6
11B4:  MOV     [--W15],W5
11B6:  RETURN  
.................... } 
.................... int16u Q8UXCount (Q8UX_STRUCT *qStructPtr) 
.................... { 
....................     return qStructPtr->count; 
.................... } 
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /************************ Software Timer Functions  *************************/ 
.................... /****************************************************************************/ 
....................  
.................... void SoftwareTimer (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr) 
.................... { 
....................     int8u k; 
....................     Q_ERR err; 
....................     for (k =0;k<nMaxSTmr;k++) 
....................     { 
....................         if(sTmrPtr[k].tmrEnb == ON) 
....................         { 
....................             sTmrPtr[k].tmrCount--; 
....................             if (sTmrPtr[k].tmrCount == 0) 
....................             { 
....................                 EvQPut (sTmrPtr[k].evQPtr, sTmrPtr[k].sTmrEvStruct, &err); 
....................                 if (err == EVQ_FULL) 
....................                 { 
....................                     EvQFullCount++; 
....................                 } 
....................                 sTmrPtr[k].tmrCount = sTmrPtr[k].tmrInit; 
....................                 if (sTmrPtr[k].tmrMode == SINGLE) 
....................                 { 
....................                     sTmrPtr[k].tmrEnb = OFF; 
....................                 } 
....................             } 
....................         } 
....................     } 
....................     return; 
.................... } 
.................... void STmrSystemDeInit (STMR_STRUCT *sTmrPtr, int8u nMaxSTmr) 
.................... { 
....................     int8u k; 
....................     for (k =0;k<nMaxSTmr;k++) 
....................     { 
....................         sTmrPtr[k].tmrEnb = OFF; 
....................         sTmrPtr[k].evQPtr = NULL; 
....................     } 
....................     return; 
.................... } 
.................... void STmrInit (STMR_STRUCT *sTmrPtr, int8u z, tickType, initValue, int8u mode, 
.................... EV_TYPE evType, void *evDataPtr, EVQ_STRUCT *evQPtr) 
.................... { 
....................     sTmrPtr[z].tmrEnb = OFF; 
....................     sTmrPtr[z].tmrMode = mode; 
....................     sTmrPtr[z].tmrInit = initValue; 
....................     sTmrPtr[z].tmrCount = initValue; 
....................     sTmrPtr[z].evQPtr = evQPtr; 
....................     EvSructInit(&(sTmrPtr[z].sTmrEvStruct), evType, evDataPtr); 
....................     return; 
.................... } 
.................... void STmrStart (STMR_STRUCT *sTmrPtr, int8u z) 
.................... { 
....................     Q_ERR err; 
....................     if (sTmrPtr[z].tmrEnb == OFF) 
....................     { 
....................         if (sTmrPtr[z].tmrCount != 0) 
....................         { 
....................             sTmrPtr[z].tmrEnb = ON; 
....................         } 
....................         else 
....................         { 
....................             EvQPut (sTmrPtr[z].evQPtr, sTmrPtr[z].sTmrEvStruct, &err); 
....................             if (err == EVQ_FULL) 
....................             { 
....................                 EvQFullCount++; 
....................             } 
....................         } 
....................     } 
....................     return; 
.................... } 
.................... void StmrPause (STMR_STRUCT *sTmrPtr, int8u z) 
.................... { 
....................     (sTmrPtr + z)->tmrEnb = OFF; 
....................     return; 
.................... } 
.................... void STmrStop (STMR_STRUCT *sTmrPtr, int8u z) 
.................... { 
....................     sTmrPtr[z].tmrEnb = OFF; 
....................     sTmrPtr[z].tmrCount = sTmrPtr[z].tmrInit; 
....................     return; 
.................... } 
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... //                           CPU Dependent Functions   
.................... /****************************************************************************/ 
....................  
.................... void DisableIntr (void) 
.................... { 
....................     disable_interrupts (INTR_GLOBAL); 
*
2234:  BCLR.B  81.7
2236:  MOV     #E0,W4
2238:  MOV     W4,42
223A:  BSET.B  81.7
223C:  RETURN  
.................... } 
.................... void EnableIntr (void) 
.................... { 
....................     enable_interrupts (INTR_GLOBAL); 
*
23D4:  BCLR.B  81.7
23D6:  CLR     42
23D8:  BSET.B  81.7
23DA:  RETURN  
.................... } 
.................... void CpuIdle (void) 
.................... { 
....................  
.................... } 
....................  
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                             LOCAL FUNCTIONS                            **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  
....................  
.................... /****************************************************************************/ 
....................  
.................... /****************************************************************************/ 
.................... /**                                                                        **/ 
.................... /**                                 EOF                                    **/ 
.................... /**                                                                        **/ 
.................... /****************************************************************************/ 
....................  

Configuration Fuses:
   Word  1L: 3F7F   WPOSTS16 WDT128 WINDIS NOWDT ICSP1 NODEBUG NOWRT NOPROTECT NOJTAG
          H: FF00  
   Word  2L: F9C7   NOPR NOALTI2C1 NOIOL1WAY OSCIO FRC_PLL SOSC_SEC WUT_DEFAULT IESO
          H: FF00  
